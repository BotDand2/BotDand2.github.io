<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CSP-S 2020 初赛 做题笔记</title>
      <link href="/post/5f05d97.html"/>
      <url>/post/5f05d97.html</url>
      
        <content type="html"><![CDATA[<ol><li><p>请选出以下最大的数（ ）。</p><p>A.$(550)_{10}$ B.$(777)_{8}$ C.$2^{10}$ D.$(22F)_{16}$</p><blockquote><p>B 的十进制数是 $511$，C 的十进制数是 $1024$，D 的十进制数是 $559$。</p><p>最大数为 $1024$，选 $C$。</p></blockquote></li><li><p>操作系统的功能是（ ）</p><p>A.负责外设与主机之间的信息交换</p><p>B.控制和管理计算机系统的各种硬件和软件资源的使用</p><p>C.负责诊断机器的故障</p><p>D.将源程序编译成目标程序</p><blockquote><p>显然答案为 $B$。</p></blockquote></li><li><p>现有一段 $8$ 分钟的视频文件，它的播放速度是每秒 $24$ 帧图像，每帧图像是 一幅分辨率为 $2048\times 1024$ 像素的 $32$ 位真彩色图像。请问要存储这段原始无压缩视频，需要多大的存储空间？（ ）。</p><p>A.$30G$ B.$90G$ C.$150G$ D.$450G$</p><blockquote><p>$8\times 60\times 24\times 2048\times 1024\times 32\div 8\div 1024\div 1024\div 1024=90$</p><p>答案为 $B$。</p></blockquote></li><li><p>今有一空栈 $S$，对下列待进栈的数据元素序列 $a,b,c,d,e,f$ 依次进行：进栈，进栈，出栈，进栈，进栈，出栈的操作，则此操作完成后，栈底元素为（ ）。</p><p>A.$b$ B.$a$ C.$d$ D.$c$</p><blockquote><p>模拟一下就会发现答案为 $B$。</p></blockquote></li><li><p>将 $(2, 7, 10, 18)$ 分别存储到某个地址区间为 $0\sim 10$ 的哈希表中，如果哈希函数 $h(x)=(\,\,\,)$，将不会产生冲突，其中 $a \bmod b$ 表示 $a$ 除以 $b$ 的余数。</p><p>A.$x^2 \bmod{11}$</p><p>B.$2\times x \bmod{11}$</p><p>C.$x \bmod{11}$</p><p>D.$\lfloor \dfrac{x}{2} \rfloor \bmod{11}$，其中 $\lfloor \dfrac{x}{2} \rfloor$ 表示 $\dfrac{x}{2}$ 下取整</p><blockquote><p>同样模拟一下就会发现答案为 $D$。</p></blockquote></li><li><p>下列哪些问题不能用贪心法精确求解？（ ）</p><p>A.霍夫曼编码问题</p><p>B.$0-1$ 背包问题</p><p>C.最小生成树问题</p><p>D.单源最短路径问题</p><blockquote><p>$0-1$ 背包是 $\texttt{DP}$，显然不能用贪心求解，选 $B$。</p></blockquote></li><li><p>具有 $n$ 个顶点，$e$ 条边的图采用邻接表存储结构，进行深度优先遍历运算的时间复杂度为（ ）。</p><p>A.$O(n+e)$</p><p>B.$O(n^2)$</p><p>C.$O(e^2)$</p><p>D.$O(n)$</p><blockquote><p>$\texttt{DFS}$ 一遍是将所有点和边都遍历<strong>一次</strong>，所以时间复杂度为 $O(n+e)$，选 $A$。</p></blockquote></li><li><p>二分图是指能将顶点划分成两个部分，每一部分内的顶点间没有边相连的简单无向图。那么，$24$ 个顶点的二分图至多有（ ）条边。</p><p>A.$144$ B.$100$ C.$48$ D.$122$</p><blockquote><p>$24$ 个顶点的二分图，每一边都有 $12$ 个点时 $12\times 12=144$ 最大，选 $A$。</p></blockquote></li><li><p>广度优先搜索时，一定需要用到的数据结构是( )</p><p>A.栈 B.二叉树 C.队列 D.哈希表</p><blockquote><p>$\texttt{BFS}$ 要用到队列，选 $C$。</p></blockquote></li><li><p>—个班学生分组做游戏，如果每组三人就多两人，每组五人就多三人，每组七人就多四人，问这个班的学生人数 $n$ 在以下哪个区间？已知 $n&lt;60$。( ）</p><p>A.$30&lt;n&lt;40$</p><p>B.$40&lt;n&lt;50$</p><p>C.$50&lt;n&lt;60$</p><p>D.$20&lt;n&lt;30$</p><blockquote><p>用中国剩余定理可知 $n=53$，选 $C$。</p></blockquote></li><li><p>小明想通过走楼梯来锻炼身体，假设从第 $1$ 层走到第 $2$ 层消耗 $10$ 卡热量，接着从第 $2$ 层走到第 $3$ 层消耗 $20$ 卡热量，再从第 $3$ 层走到第 $4$ 层消耗 $30$ 卡热量，依此类推，从第 $k$ 层走到第 $k+1$ 层消耗 $10k$ 卡热量 $(k&gt;1)$？如果小明想从 $1$ 层开始，通过连续向上爬楼梯消耗 $1000$ 卡热量，至少要爬到第几层楼？ （ ）。</p><p>A.$14$ B.$16$ C.$15$ D.$13$</p><blockquote><p>小学奥数题，答案为 $C$。</p></blockquote></li><li><p>表达式 <code>a*(b+c)-d</code> 的后缀表达形式为（ ）。</p><p>A.$\texttt{abc*+d-}$</p><p>B.$\texttt{-+*abcd}$</p><p>C.$\texttt{abcd*+-}$</p><p>D.$\texttt{abc+*d-}$</p><blockquote><p>如下图：</p><p><img src="https://img.gejiba.com/images/1c90934e95bc073e12c3fa609eebeefa.png" alt=""></p><p>后缀形式为 <code>abc+*d-</code>，选 $D$。</p></blockquote></li><li><p>从一个 $4 \times 4$ 的棋盘中选取不在同一行也不在同一列上的两个方格，共有（ ）种方法。</p><p>A.$60$ B.$72$ C.$86$ D.$64$</p><blockquote><p>第一个方格有 $4\times 4$ 种选法，第二个方格有 $3\times 3$ 种选法，因为会重复计算，所以答案为 $4\times 4\times 3\times 3\div 2=72$ 种，选 $B$。</p></blockquote></li><li><p>对一个 $n$ 个顶点、$m$ 条边的带权有向简单图用 $\texttt{Dijkstra}$ 算法计算单源最短路时，如果不使用堆或其它优先队列进行优化，则其时间复杂度为（ ）。</p><p>A.$O((m + n^{2}) \log n)$</p><p>B.$O(mn + n^{3})$</p><p>C.$O((m + n) \log n)$</p><p>D.$O(n^{2})$</p><blockquote><p>注意是没有优化的 $\texttt{Dijkstra}$，所以时间复杂度为 $O(n^{2})$，选 $D$。</p></blockquote></li><li><p>1948 年，（ ）将热力学中的熵引入信息通信领域，标志着信息论研究的开端。</p><p>A.欧拉(Leonhard Euler)</p><p>B.冯·诺伊曼(John von Neumann)</p><p>C.克劳德·香农(Claude Shannon)</p><p>D.图灵(Alan Turing)</p><blockquote><p>答案为 $C$。</p></blockquote></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> CSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斜率优化 学习笔记</title>
      <link href="/post/f0a9145e.html"/>
      <url>/post/f0a9145e.html</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li><p>会 $\texttt{DP}$。</p></li><li><p>会<strong>单调队列</strong></p></li><li><p>斜率公式 $k=\dfrac{y_{2}-y_{1}}{x_{2}-x_{1}}$。</p></li></ul><h2 id="斜率优化-DP"><a href="#斜率优化-DP" class="headerlink" title="斜率优化 DP"></a>斜率优化 DP</h2><p>首先可以斜率优化的通常有如下式子：</p><script type="math/tex; mode=display">dp_{i}=\min/\max\{a_{i}\times b_{j}+c_{i}+d_{j}+C\}\,\,\,\,\,\,\,\,\,\,\,(j<i)</script><p>有如下约定：</p><ul><li><p>$C$，$c_{i}$，$d_{i}$（之一）可能不存在，主要是 $a_{i}\times b_{j}$（没有 $a_{i}\times b_{j}$ 的叫单调队列优化）</p></li><li><p>$a_{i}$，$b_{j}$，$c_{i}$，$d_{j}$ 表示只与 $i$ 或 $j$  有关的函数。</p></li><li><p>$C$ 表示常数。</p></li></ul><p>如果直接暴力时间复杂度为 $O(n^{2})$，不够优，于是考虑优化。</p><p>将式子中可以提取的东西先提出来：</p><script type="math/tex; mode=display">dp_{i}=\min/\max\{a_{i}\times b_{j}+d_{j}\}+c_{i}+C\,\,\,\,\,\,\,\,\,\,\,(j<i)</script><p>先去掉 $\min/\max$（下文默认 $j&lt;i$）。</p><script type="math/tex; mode=display">dp_{i}=a_{i}\times b_{j}+d_{j}</script><p>考虑如果存在 $j1,j2$ 使得 $j2$ 优于 $j1$ 会怎么样（下文默认式子都为 $\max$）。</p><script type="math/tex; mode=display">a_{i}\times b_{j1}+d_{j1}<a_{i}\times b_{j2}+d_{j2}\\a_{i}\times (b_{j1}-b_{j2})<d_{j2}-d_{j1}\\-a_{i}>\dfrac{d_{j2}-d_{j1}}{b_{j2}-b_{j1}}</script><p>然后可以令</p><p>$k_{0}=-a_{i}$，$x_{x}=b_{x}$，$y_{x}=d_{x}$。</p><p>于是式子变成了</p><script type="math/tex; mode=display">k_{0}>\dfrac{y_{j2}-y_{j1}}{x_{j2}-x_{j1}}</script><p>注意需要保证 $x_{j2}&gt;x_{j1}$。</p><p>可以发现这个东西非常像斜率式。</p><p>将决策点 $X,Y$ 丢进平面。</p><p>假设有三个决策点组成点 $A,B,C$。</p><p>$A-B$ 斜率为 $k_{1}$，$B-C$ 斜率为 $k_{2}$。</p><hr><p><strong>当 $k_{1}&gt;k_{2}$ 时</strong></p><p><img src="https://img.gejiba.com/images/d58ba6f634014123ea7a57bd042fe07d.png" alt=""></p><ul><li><p>$k_{0}&gt;k_{1}$ 时，$B$ 优于 $A$，反之 $A$ 优于 $B$。</p></li><li><p>$k_{0}&gt;k_{2}$ 时，$C$ 优于 $B$，反之 $B$ 优于 $C$。</p></li></ul><p>有三种情况：</p><ul><li><p>$k_{0}&gt;k_{1}&gt;k_{2}$，$C$ 优于 $B$ 优于 $A$。</p></li><li><p>$k_{1}&gt;k_{0}&gt;k_{2}$，$A$ 和 $C$ 优于 $B$。</p></li><li><p>$k_{1}&gt;k_{2}&gt;k_{0}$，$A$ 优于 $B$ 优于 $C$。</p></li></ul><p>综上所述，$B$ 永远不会成为决策点。</p><p><img src="https://img.gejiba.com/images/bb7966ea7cd9bcd874f970b2410d68c7.png" alt=""></p><p>不难发现，可能成为决策点的点形成了下凸壳：</p><p><img src="https://img.gejiba.com/images/a74ad97bbb554942c2bb8693c14850d1.png" alt=""></p><hr><p><strong>当 $k_{1}&lt;k_{2}$ 时</strong></p><p>同上，会形成一个上凸壳。</p><hr><p>考虑如何维护答案。</p><p>下文默认下凸壳。</p><p>假设平面上已经维护了一个凸壳，现在需要知道 $dp_{i}$，假设 $i$ 对应的斜率 $k_{i}$ 是图中的紫线。</p><p><img src="https://img.gejiba.com/images/3bd3cd45c71b737f6f8de294fdb5efd1.png" alt=""></p><p>不难发现答案即为 $4$ 号点：</p><p><img src="https://img.gejiba.com/images/baf7f52e6d2798d67dbf6ad4fe4caedd.png" alt=""></p><p>设维护出凸包的点集为 $\big\{(x_{i},y_{i})\big\}(i\in[1,m])$，$m$ 为集合大小。</p><p>由于凸壳的性质，这些点满足：$\dfrac{y_{i}-y_{i+1}}{x_{i}-x_{i+1}}&lt;\dfrac{y_{j}-y_{j+1}}{x_{j}-x_{j+1}}$，其中 $i&lt;j$，$i$ 和 $j\in[1,m)]$，通俗的讲就是前面的斜率小于后面的斜率。</p><p>考虑单调队列维护。</p><p>先算出 $i$ 点的 $k_{0}$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> k0=...;</span><br></pre></td></tr></table></figure><p>用暴力的方法找到决策点，不同于暴力的是不符合条件的会被直接弹出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//           &lt;=</span></span><br><span class="line"><span class="keyword">while</span>(l&lt;r&amp;&amp;k0&gt;=<span class="built_in">k</span>(q[l],q[l+<span class="number">1</span>])) l++;</span><br><span class="line"><span class="comment">// 其中 k 表示计算斜率</span></span><br><span class="line"><span class="type">int</span> j=q[l];<span class="comment">// 找到决策点</span></span><br><span class="line">dp[i]=...;<span class="comment">// 更新</span></span><br></pre></td></tr></table></figure><p>在插入新的决策点时，要先将不符合凸性的点弹出队。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//                       &lt;=</span></span><br><span class="line"><span class="keyword">while</span>(l&lt;r&amp;&amp;<span class="built_in">k</span>(q[r],q[r<span class="number">-1</span>])&gt;=<span class="built_in">k</span>(i,q[r<span class="number">-1</span>])) r--;<span class="comment">// 弹出不符合单调性的点</span></span><br><span class="line">q[++r]=i;<span class="comment">// 将 i 入队</span></span><br></pre></td></tr></table></figure><p>这样斜率优化 $\texttt{DP}$ 就做好了，将 $O(n^{2})$ 优化为 $O(n)$。</p><div class="note warning flat"><p>注意事项：</p><ol><li><p>有时将除法写成乘法以保证精度；</p></li><li><p>注意初值，从 $0$ 号点（也就是从头）转移有时要提前在凸壳里加入 $\{0,0\}$ 等初值；</p></li><li><p>加点和统计答案是两个不同的事件，不是所有题目都统计完就加点；</p></li><li><p>注意<strong>要维护严格凸的凸壳</strong>，而不是下面这样（共线）：</p><p><img src="https://img.gejiba.com/images/957911e6fef754370163b73e1001001c.png" alt=""></p></li></ol></div><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P3628">P3628</a></p><p>思路在代码里。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,a,b,c;</span><br><span class="line"><span class="type">int</span> x[<span class="number">1000002</span>];</span><br><span class="line"><span class="type">int</span> s[<span class="number">1000002</span>];</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"><span class="type">int</span> q[<span class="number">1000002</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1000002</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">X</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Y</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dp[x]+a*s[x]*s[x]-b*s[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">k</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span>*(<span class="built_in">Y</span>(x)-<span class="built_in">Y</span>(y))/(<span class="built_in">X</span>(x)-<span class="built_in">X</span>(y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// dp[i] 表示以 i 为某一队的结尾所能获得的最大价值</span></span><br><span class="line">    <span class="comment">// dp[i]=max&#123;dp[j]+a*(s[i]-s[j])^2+b*(s[i]-s[j])+c&#125; (j&lt;i)</span></span><br><span class="line">    <span class="comment">// s 表示前缀和</span></span><br><span class="line">    <span class="comment">// dp[i]=max&#123;dp[j]+a*s[i]^2-2*a*s[i]*s[j]+a*s[j]^2+b*s[i]-b*s[j]+c&#125;</span></span><br><span class="line">    <span class="comment">// dp[i]=max&#123;dp[j]-2*a*s[i]*s[j]+a*s[j]^2-b*s[j]&#125;+a*s[i]^2+b*s[i]+c</span></span><br><span class="line">    <span class="comment">// 若 j2 优于 j1，则</span></span><br><span class="line">    <span class="comment">// dp[j1]-2*a*s[i]*s[j1]+a*s[j1]^2-b*s[j1]&lt;dp[j2]-2*a*s[i]*s[j2]+a*s[j2]^2-b*s[j2]</span></span><br><span class="line">    <span class="comment">// 2*a*s[i]*(s[j2]-s[j1])&lt;(dp[j2]+a*s[j2]^2-b*s[j2])-(dp[j1]+a*s[j1]^2+b*s[j1])</span></span><br><span class="line">    <span class="comment">// 2*a*s[i]&lt;((dp[j2]+a*s[j2]^2-b*s[j2])-(dp[j1]+a*s[j1]^2+b*s[j1]))/(s[j2]-s[j1])</span></span><br><span class="line">    <span class="comment">// 保证 s[j2]&gt;s[j1]</span></span><br><span class="line">    <span class="comment">// 令 X[x]=s[x],Y[x]=dp[x]+a*s[x]^2-b*s[x],k0=2*a*s[i]</span></span><br><span class="line">    <span class="comment">// k0&lt;(Y[j2]-Y[j1])/(X[j2]-X[j1])</span></span><br><span class="line">    <span class="comment">// 维护上凸包</span></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) cin&gt;&gt;x[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) s[i]=s[i<span class="number">-1</span>]+x[i];</span><br><span class="line">    l=<span class="number">0</span>;r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k0=<span class="number">2</span>*a*s[i];</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;k0&lt;=<span class="built_in">k</span>(q[l],q[l+<span class="number">1</span>])) l++;</span><br><span class="line">        <span class="type">int</span> j=q[l],S=s[i]-s[j];</span><br><span class="line">        dp[i]=dp[j]+a*S*S+b*S+c;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;<span class="built_in">k</span>(q[r],q[r<span class="number">-1</span>])&lt;=<span class="built_in">k</span>(i,q[r<span class="number">-1</span>])) r--;</span><br><span class="line">        q[++r]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学了好久才明白。</p><p>更多例题：<a href="https://www.luogu.com.cn/problem/P3195">P3195</a>，<a href="https://www.luogu.com.cn/problem/P2365">P2365</a>。</p><p>参考资料：</p><p><a href="https://www.luogu.com.cn/blog/ningago-lsh/xie-lv-you-hua-dp">https://www.luogu.com.cn/blog/ningago-lsh/xie-lv-you-hua-dp</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP-S 2021 初赛 做题笔记</title>
      <link href="/post/a44fe165.html"/>
      <url>/post/a44fe165.html</url>
      
        <content type="html"><![CDATA[<ol><li><p>在 Linux 系统终端中，用于列出当前目录下所含的文件和子目录的命令为（ ）。</p><p>A.$\text{ls}$ B.$\text{cd}$ C.$\text{cp}$ D.$\text{all}$</p><blockquote><p>显然答案为 $A$。</p></blockquote></li><li><p>二进制数 $00101010_{2}$ 和 $00010110_{2}$ 的和为（ ）。</p><p>A.$00111100_{2}$ B.$01000000_{2}$ C.$00111100_{2}$ D.$01000010_{2}$</p><blockquote><p>显然答案为 $B$。</p></blockquote></li><li><p>在程序运行过程中，如果递归调用的层数过多，可能会由于（ ）引发错误。</p><p>A.系统分配的栈空间溢出</p><p>B.系统分配的队列空间溢出</p><p>C.系统分配的链表空间溢出</p><p>D.系统分配的堆空间溢出</p><blockquote><p>递归调用的是栈空间，所以选 $A$。</p></blockquote></li><li><p>以下排序方法中，（ ）是不稳定的。</p><p>A.插入排序 B.冒泡排序 C.堆排序 D.归并排序</p><blockquote><p>除了堆排序，其他都是稳定的，所以选 $C$。</p></blockquote></li><li><p>以比较为基本运算，对于 $2n$ 个数，同时找到最大值和最小值，最坏情况下需要的最小的比较次数为（ ）。</p><p>A.$4n-2$ B.$3n+1$ C.$3n-2$ D.$2n+1$</p><blockquote><p>首先可以比较 $n$ 次，分出 $a_{i\times 2-1}$ 与 $a_{i*2}$ 中较小的与较大的。显然最小数必然在较小的那组，最大数必然在较大的那组，由于第一个数不用比较，所以最少的比较次数为 $3n-2$，选 $C$。</p></blockquote></li><li><p>现有一个地址区间为 $0\sim 10$ 的哈希表，对于出现冲突情况，会往后找第一个空的地址存储 （到 $10$ 冲突了就从 $0$ 开始往后），现在要依次存储 $(0,1,2,3,4,5,6,7)$，哈希函数为 $h(x)=x^{2} \bmod {11}$。请问 $7$ 存储在哈希表哪个地址中（ ）。</p><p>A.$5$ B.$6$ C.$7$ D.$8$</p><blockquote><p>$h(0)=0$；</p><p>$h(1)=1$；</p><p>$h(2)=4$；</p><p>$h(3)=9$；</p><p>$h(4)=5$；</p><p>$h(5)=4$，因为 $4$，$5$ 都有了，所以 $h(5)=6$；</p><p>$h(6)=3$；</p><p>$h(7)=5$，因为 $5$，$6$ 都有了，所以 $h(7)=7$。</p><p>所以选 $C$。</p></blockquote></li><li><p>$G$ 是一个非连通简单无向图（没有自环和重边），共有 $36$ 条边，则该图至少有（ ）个点。</p><p>A.$8$ B.$9$ C.$10$ D.$11$</p><blockquote><p>首先 $9$ 个点最多可以有 $\dfrac{9\times 8}{2}=36$ 条边，但因为 $G$ 是非联通图，于是再加一个点独立成为一个连通块，所以答案为 $C$。</p></blockquote></li><li><p>令根结点的高度为 $1$，则一棵含有 $2021$ 个结点的二叉树的高度至少为（ ）。</p><p>A.$10$ B.$11$ C.$12$ D.$2021$</p><blockquote><p>显然高度为 $n$ 的最多有 $2^{n}-1$ 的节点，带入算即可，选 $B$。</p></blockquote></li><li><p>前序遍历和中序遍历相同的二叉树为且仅为（ ）。</p><p>A.只有 $1$ 个点的二叉树</p><p>B.根结点没有左子树的二叉树</p><p>C.非叶子结点只有左子树的二叉树</p><p>D.非叶子结点只有右子树的二叉树</p><blockquote><p>前序遍历是先访问根节点，再访问左节点，最后访问右节点；</p><p>中序遍历是先访问左节点，再访问根节点，最后访问右节点；</p><p>不难发现如果都没有左节点，前序遍历和中序遍历就是一样的。</p><p>答案选 $D$。</p></blockquote></li><li><p>定义一种字符串操作为交换相邻两个字符。将 $\texttt{DACFEB}$ 变为 $\texttt{ABCDEF}$ 最少需要 ( ) 次上述操作。</p><p>A.$7$ B.$8$ C.$9$ D.$6$</p><blockquote><p>操作如下：</p><p>$0:\texttt{DACFEB}$；</p><p>$1:\texttt{ADCFEB}$；</p><p>$2:\texttt{ADCFBE}$；</p><p>$3:\texttt{ADCBFE}$；</p><p>$4:\texttt{ADBCFE}$；</p><p>$5:\texttt{ABDCFE}$；</p><p>$6:\texttt{ABCDFE}$；</p><p>$7:\texttt{ABCDEF}$；</p><p>选 $A$。</p></blockquote></li><li><p>有如下递归代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">solve</span>(t,n):</span><br><span class="line">  <span class="keyword">if</span> t=<span class="number">1</span> <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">5</span>*<span class="built_in">solve</span>(t<span class="number">-1</span>,n) mod n</span><br></pre></td></tr></table></figure><p>则 <code>solve(23,23)</code> 的结果为（ ）。</p><p>A.$1$ B.$7$ C.$12$ D.$22$</p><blockquote><p>不难发现答案为 $5^{22}\bmod 23$，即为 $1$，选 $A$。</p></blockquote></li><li><p>斐波那契数列的定义为： $F_{1}=1$，$F_{2}=1$，$F_{n}=F_{n-1}+F_{n-2}$ $(n\geq 3)$。现在用如下程序来计算斐波那契数列的第 $n$ 项，其时间复杂度为（ ）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">F</span>(n):</span><br><span class="line">  <span class="keyword">if</span> n&lt;=<span class="number">2</span> <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">F</span>(n<span class="number">-1</span>) + <span class="built_in">F</span>(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure><p>A.$O(n)$</p><p>B.$O(n^{2})$</p><p>C.$O(2^{n})$</p><p>D.$O(n\log n)$</p><blockquote><p>模拟一下 $n=5$ 的情况：</p><p><img src="https://img.gejiba.com/images/5516e1e405cc3f7e74047db01a80188b.png" alt=""></p><p>可以发现这与满二叉树非常相似，于是选 $C$。</p></blockquote></li><li><p>有 $8$ 个苹果从左到右排成一排，你要从中挑选至少一个苹果，并且不能同时挑选相邻的两个苹果，一共有（ ）种方案。</p><p>A.$36$ B.$48$ C.$54$ D.$64$</p><blockquote><p>选一个苹果：$8$ 种；</p><p>选两个苹果：$6+5+4+3+2+1=21$ 种；</p><p>选三个苹果：$(4+3+2+1)+(3+2+1)+(2+1)+1=20$种；</p><p>选四个苹果：$(2+1)+1+1=5$ 种；</p><p>所以总共有 $8+21+20+5=54$ 种，选 $C$。</p></blockquote></li><li><p>设一个三位数 $n=\overline{abc}$，$a,b,c$ 均为 $1\sim 9$ 之间的整数，若以 $a$、 $b$、 $c$ 作为三角形的三条边可以构成等腰三角形（包括等边），则这样的 $n$ 有（ ）个。</p><p>A.$81$ B.$120$ C.$165$ D.$216$</p><blockquote><p>$a=b=c$：$9$ 种；</p><p>$a=b=1$，$a\not= c$：$0&lt;c&lt;2$，$0$ 种；</p><p>$a=b=2$，$a\not= c$：$0&lt;c&lt;4$，$2$ 种；</p><p>$a=b=3$，$a\not= c$：$0&lt;c&lt;6$，$4$ 种；</p><p>$a=b=4$，$a\not= c$：$0&lt;c&lt;8$，$6$ 种；</p><p>$a=b=5$，$a\not= c$：$0&lt;c&lt;10$，$8$ 种；</p><p>$a=b=6$，$a\not= c$：$0&lt;c&lt;10$，$8$ 种；</p><p>$a=b=7$，$a\not= c$：$0&lt;c&lt;10$，$8$ 种；</p><p>$a=b=8$，$a\not= c$：$0&lt;c&lt;10$，$8$ 种；</p><p>$a=b=9$，$a\not= c$：$0&lt;c&lt;10$，$8$ 种；</p><p>接下来还有 $b=c$，$a=c$，与 $a=b$ 种数相同。</p><p>于是答案为 $9+(0+2+4+6+8+8+8+8+8)\times 3=165$ 种，选 $C$。</p></blockquote></li><li><p>有如下的有向图，节点为 $A,B,\cdots ,J$, 其中每条边的长度都标在图中。则节点 $A$ 到节点 $J$ 的最短路径长度为（ ）。</p><p><img src="https://ipic.luogu.com.cn/l7l0c.png" alt=""></p><p>A.$16$ B.$19$ C.$20$ D.$22$</p><blockquote><p>如图中红色路径：</p><p><img src="https://img.gejiba.com/images/0885d3792b9be945d66d4e7302b734a0.png" alt=""></p><p>答案为 $B$。</p></blockquote></li></ol><p><img src="https://ipic.luogu.com.cn/1rorg.png" alt=""></p><ol><li><p>将第 $21$ 行中 $t$ 的类型声明从 <code>int</code> 改为 <code>double</code>， 不会 影响程序运行的结果。（）</p><blockquote><p>正确，因为 $sq$ 函数返回值也是 <code>int</code> 不会有影响。</p></blockquote></li><li><p>将第 $26$、$27$ 行中的 <code>/ sqrt(t) / 2</code>替换为 <code>/ 2 / sqrt(t)</code>，不会影响程序运行的结果。（ ）</p><blockquote><p>错误，因为先除以 $\text{sqrt}$ 会将类型强制转为 <code>double</code>，而先除以 $2$ 不会。</p></blockquote></li><li><p>将第 $28$ 行中的 <code>x * x</code> 改成 <code>sq(x)</code>、<code>y * y</code> 改成 <code>sq(y)</code>，不会影响程序运行的结果。（ ）</p><blockquote><p>错误，<code>x*x</code> 返回的是 <code>double</code>，而 <code>sq(x)</code> 返回的是 <code>int</code>。</p></blockquote></li><li><p>当输入为 <code>0 0 0 1 1 0 0 1</code> 时，输出为 <code>1.3090</code> ( )</p><blockquote><p>正确，手动模拟一下即可。其中 $r$ 为 $\dfrac{\pi}{3}$。</p></blockquote></li><li><p>当输入为 <code>1 1 1 1 1 1 1 2</code> 时，输出为（ ）。</p><p>A.<code>3.1416</code></p><p>B.<code>6.2832</code></p><p>C.<code>4.7124</code></p><p>D.<code>4.1888</code></p><blockquote><p>也是手动模拟一下即可，选 $D$。</p></blockquote></li><li><p>这段代码的含义为（ ）。</p><p>A.求圆的面积并</p><p>B.求球的体积并</p><p>C.求球的体积交</p><p>D.求椭球的体积并</p><blockquote><p>注意到 $r=\dfrac{\pi}{3}$，而球的体积公式为 $V=\dfrac{4}{3}\pi R^{3}$；第 $23$ 输出的是 $\min(d_{1},d_{2})$，于是可以想到是求球的体积交，选 $C$。</p></blockquote></li></ol><p><img src="https://ipic.luogu.com.cn/u921e.png" alt=""></p><p><img src="https://ipic.luogu.com.cn/7f6vs.png" alt=""></p><ol><li><p>程序总是会正常执行并输出两行两个相等的数。（ ）</p><blockquote><p>正确，<code>solve1</code> 和 <code>solve2</code> 都是在求最大子段和。</p></blockquote></li><li><p>第 $28$ 行与第 $38$ 行分别有可能执行两次及以上。（ ）</p><blockquote><p>错误，二分到边界时，只会出现 $h=m$  的情况，如果输入的 $n&lt;0$，则回执行一次。</p></blockquote></li><li><p>当输入为 <code>5 -10 11 -9 5 -7</code> 时，输出的第二行为 <code>7</code>。( )</p><blockquote><p>错误，最大子段和为 <code>11</code>，注意第一个数是 $n$。</p></blockquote></li><li><p><code>solve1(1, n)</code> 的时间复杂度为（ ）。</p><p>A.$O(\log n)$</p><p>B.$O(n)$</p><p>C.$O(n \log n)$</p><p>D.$O(n^{2})$</p><blockquote><p>$T(n)=2\times T(\dfrac{n}{2})+1$，$T(n)=2\times n-1$，选 $B$。</p></blockquote></li><li><p><code>solve2(1, n)</code> 的时间复杂度为（ ）。</p><p>A.$O(\log n)$</p><p>B.$O(n)$</p><p>C.$O(n \log n)$</p><p>D.$O(n^{2})$</p><blockquote><p>$T(n)=2\times T(\dfrac{n}{2})+n$，复杂度是 $O(n\log n)$，选 $C$。</p></blockquote></li><li><p>当输入为 <code>10 -3 2 10 0 -8 9 -4 -5 9 4</code> 时，输出的第一行为（ ）。</p><p>A.$13$</p><p>B.$17$</p><p>C.$24$</p><p>D.$12$</p><blockquote><p>最大子段为 <code>2 10 0 -8 9 -4 -5 9 4</code>，同样需要注意第一个 $10$ 是 $n$，选 $B$。</p></blockquote></li></ol><p><img src="https://ipic.luogu.com.cn/k2oqx.png" alt=""></p><p><img src="https://ipic.luogu.com.cn/uhixa.png" alt=""></p><ol><li><p>程序总是先输出 <strong>一行</strong> 一个整数，再输出 <strong>一行</strong> 一个字符串。（ ）</p><blockquote><p>错误，解密的字符串中可能有换行符。</p></blockquote></li><li><p>对于任意不含空白字符的字符串 <code>str1</code>，先执行程序输入 <code>0 str1</code>，得到输出的第二行记为 <code>str2</code> 再执行程序输入 <code>1 str2</code>，输出的第二行必为 <code>str1</code>。（ ）</p><blockquote><p>正确，就是解密与加密。</p></blockquote></li><li><p>当输入为 <code>1 SGVsbG93b3JsZA==</code> 时，输出的第二行为 <code>HelloWorld</code>。( )</p><blockquote><p>错误，手动模拟一下发现答案是 <code>Helloworld</code>。</p></blockquote></li><li><p>设输入字符串长度为 $n$，<code>encode</code> 函数的时间复杂度为（ ）。</p><p>A.$O(\sqrt{n})$</p><p>B.$O(n)$</p><p>C.$O(n\log n)$</p><p>D.$O(n^2)$</p><blockquote><p>显然是 $O(n)$，选 $B$。</p></blockquote></li><li><p>输出的第一行为（ ）。</p><p>A.<code>0xff</code></p><p>B.<code>255</code></p><p>C.<code>0xFF</code></p><p>D.<code>-1</code></p><blockquote><p>是 $-1$，可能是操作系统的问题，选 $D$。</p></blockquote></li><li><p>当输入为 <code>0 CSP2021csp</code> 时，输出的第二行为（ ）。</p><p>A.<code>Q1NQMjAyMWNzcAv=</code></p><p>B.<code>Q1NQMjAyMGNzcA==</code></p><p>C.<code>Q1NQMjAyMGNzcAv=</code></p><p>D.<code>Q1NQMjAyMWNzcA==</code></p><blockquote><p>还是要手动模拟，选 $D$。</p></blockquote></li></ol><p>（魔法数字） 小 H 的魔法数字是 $4$。给定 $n$， 他希望用若干个 $4$ 进行若干次加法、减法和整除运算得到 $n$。但由于小 H 计算能力有限，计算过程中只能出现不超过 $M=10000$ 的正整数。求至少可能用到多少个 $4$。<br>例如，当 $n=2$ 时，有 $2=\dfrac{4 + 4}{4}$，用到了 $3$ 个 $4$，是最优方案。<br><img src="https://ipic.luogu.com.cn/ink47.png" alt=""></p><p><img src="https://ipic.luogu.com.cn/xp28q.png" alt=""></p><ol><li><p>①处应填（ ）</p><p>A.<code>F[4] = 0</code></p><p>B.<code>F[1] = 4</code></p><p>C.<code>F[1] = 2</code></p><p>D.<code>F[4] = 1</code></p><blockquote><p>得到 $4$ 只需要 $1$ 次，于是 <code>F[4]=1</code>，选 $D$。</p></blockquote></li><li><p>②处应填（ ）</p><p>A.<code>!Vis[n]</code></p><p>B.<code>r &lt; n</code></p><p>C.<code>F[M] == INT_MAX</code></p><p>D.<code>F[n] == INT_MAX</code></p><blockquote><p>如果它已经能作为一个最小值可以去更新其他的数，即 <code>Vis[n]==1</code> 时答案最优，选 $A$。</p></blockquote></li><li><p>③处应填（ ）</p><p>A.<code>F[i] == r</code></p><p>B.<code>!Vis[i] &amp;&amp; F[i] == r</code></p><p>C.<code>F[i] &lt; F[x]</code></p><p>D.<code>!Vis[i] &amp;&amp; F[i] &lt; F[x]</code></p><blockquote><p>首先得保证当前的 $i$ 不是最优，即 <code>Vis[i]=0</code>，然后找出 <code>F[i]</code> 中的最小值，选$D$。</p></blockquote></li><li><p>④处应填（ ）</p><p>A.<code>F[i] &lt; F[x]</code></p><p>B.<code>F[i]&lt;=r</code></p><p>C.<code>Vis[i]</code></p><p>D.<code>i &lt;= x</code></p><blockquote><p>保证当前的 $i$ 最优即可，用 $x$ 与 $i$ 去更新下一个数，选 $C$。</p></blockquote></li></ol><p>（ RMQ 区间最值问题）给定序列 $a_0,\cdots,a_{n-1}$，$m$ 次询问，每次询问给定 $l,r$，求 $\max \{a_l,\ …,a_r\}$。<br>为了解决该问题，有一个算法叫 <strong>the Method of Four Russians</strong>，其时间复杂度为 $O(n+m)$ ，步骤如下：<br>建立 Cartesian（笛卡尔）树，将问题转化为树上的 LCA（最近公共祖先）问题。<br>对于 LCA 问题，可以考虑其 Euler 序（即按照 DFS 过程，经过所有点，环游回根的序列），即求 Euler 序列上两点间一个新的 RMQ 问题。<br>注意新的问题为 $\pm 1$ RMQ，即相邻两点的深度差一定为 $1$。<br>下面解决这个 $\pm 1$ RMQ 问题，“序列”指 Euler 序列：<br>设 $t$ 为 Euler 序列长度。取 $b=\lceil \frac{\log_2 t}{2} \rceil$ 将序列每 $b$ 个分为一大块，使用 ST 表（倍增表）处理大块间的 RMQ 问题，复杂度 $O(\frac{t}{b}\log t)=O(n)$<br>（重点） 对于一个块内的 RMQ 问题，也需要 $O(1)$ 的算法。由于差分数组 $2^{b-1}$ 种，可以预处理出所有情况下的最值位置，预处理复杂度 $O(b2^b)$，不超过 $O(n)$。<br>最终，对于一个查询，可以转化为中间整的大块的 RMQ 问题，以及两端块内的 RMQ 问题。<br>试补全程序。</p><p><img src="https://ipic.luogu.com.cn/xk90i.png" alt=""></p><p><img src="https://ipic.luogu.com.cn/28mlp.png" alt=""></p><p><img src="https://ipic.luogu.com.cn/yrnei.png" alt=""></p><p><img src="https://ipic.luogu.com.cn/efrqf.png" alt=""></p><ol><li><p>①处应填（ ）</p><p>A.<code>p-&gt;son[0] = S[top--]</code></p><p>B.<code>p-&gt;son[1] = S[top--]</code></p><p>C.<code>S[top--]-&gt;son[0] = p</code></p><p>D.<code>S[top--]-&gt;son[1] = p</code></p></li><li><p>②处应填（ ）</p><p>A.<code>p-&gt;son[0] = S[top]</code></p><p>B.<code>p-&gt;son[1] = S[top]</code></p><p>C.<code>S[top]-&gt;son[0] = p</code></p><p>D.<code>S[top]-&gt;son[1] = p</code></p></li><li><p>③处应填（ ）</p><p>A.<code>x-&gt;dep &lt; y-&gt;dep</code></p><p>B.<code>x &lt; y</code></p><p>C.<code>x-&gt;dep &gt; y-&gt;dep</code></p><p>D.<code>x-&gt;val &lt; y-&gt;val</code></p></li><li><p>④处应填（ ）</p><p>A.<code>A[i * b + j - 1] == A[i * b + j]-&gt;son[0]</code></p><p>B.<code>A[i * b + j]-&gt;val &lt; A[i * b + j - 1]-&gt;val</code></p><p>C.<code>A[i * b + j] == A[i * b + j - 1]-&gt;son[1]</code></p><p>D.<code>A[i * b + j]-&gt;dep &lt; A[i * b + j - 1]-&gt;dep</code></p></li><li><p>⑤处应填（ ）</p><p>A.<code>v += (S &gt;&gt; i &amp; 1) ? -1 : 1</code></p><p>B.<code>v += (S &gt;&gt; i &amp; 1) ? 1 : -1</code></p><p>C.<code>v += (S &gt;&gt; (i - 1) &amp; 1) ? 1 : -1</code></p><p>D.<code>v += (S &gt;&gt; (i - 1) &amp; 1) ? -1 : 1</code></p></li><li><p>⑥处应填（ ）</p><p>A.<code>(Dif[p] &gt;&gt; (r - p * b)) &amp; ((1 &lt;&lt; (r - l)) - 1)</code></p><p>B.<code>Dif[p]</code></p><p>C.<code>(Dif[p] &gt;&gt; (l - p * b)) &amp; ((1 &lt;&lt; (r - l)) - 1)</code></p><p>D.<code>(Dif[p] &gt;&gt; ((p + 1) * b - r)) &amp; ((1 &lt;&lt; (r - l + 1)) - 1)</code></p></li></ol><blockquote><p>神仙题，不会，答案是 $ADADDC$。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> CSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初赛</title>
      <link href="/post/60697891.html"/>
      <url>/post/60697891.html</url>
      
        <content type="html"><![CDATA[<p>模拟试题：<a href="https://wzyqwq.lanzoui.com/iWxKqtujqmb">https://wzyqwq.lanzoui.com/iWxKqtujqmb</a></p><p>答案：<a href="https://wzyqwq.lanzoui.com/iftwHu726yj?w">https://wzyqwq.lanzoui.com/iftwHu726yj?w</a></p><h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1.基础知识"></a>1.基础知识</h2><ul><li>计算机的发展</li></ul><p>世界上第一台电子计算机：$\color{red}\text{ENIAC}$，于 $\text{1946}$ 年由美固宾夕法尼亚大学的物理学家 约翰·莫克利（$\texttt{John Mauchly}$）和工程师 普雷斯伯·埃克特（$\texttt{J.hesper.Eckert}$）领导研制。</p><p>世界上第一台具有存储程序功能的计算机：$\color{red}\text{EDVAC}$，由 <strong>冯·诺依曼</strong> 设计。</p><p>同 ENIAC 相比，EDVAC 方案有两个重大改进：</p><ol><li>采用了 $\color{blue}\text{二进制}$。</li><li>提出了 $\color{blue}\text{“存储程序”}$ 。</li></ol><ul><li>与计算机有关的人物：</li></ul><ol><li>冯·诺依曼（美）：现代计算机之父，<strong>首次</strong>提出了<strong>存储程序控制原理</strong>，称为“冯·诺依曼结构”。</li><li>艾伦·麦席森·图灵（英）：计算机科学/人工智能之父，<strong>首次</strong>提出了<strong>计算机科学理论</strong>。计算机界的<strong>最高奖项</strong> $\color{red}\text{“图灵奖”}$ 以他命名，被称为“<strong>计算机界的诺贝尔奖</strong>”。</li><li>阿达·洛芙莱斯（$\texttt{Ada Lovelace}$）：<strong>英国</strong>著名诗人 拜伦 的女儿，由于她在程序设计上的开创性工作，被称为世界上 $\color{blue}\text{“第一位程序员”}$，$\color{blue}\text{“世界上第一位软件工程师”}$。</li><li>董铁宝：中国第一个程序员，<strong>王选</strong> 的老师。</li><li>姚期智：因对计算理论做出了诸多根本性的重大贡献而获得<strong>图灵奖</strong>。</li></ol><ul><li>计算机发展的几个阶段</li></ul><ol><li>第一代（$\text{1946}\sim\text{1958}$）：电子管。</li><li>第二代（$\text{1958}\sim\text{1964}$）：晶体管。</li><li>第三代（$\text{1964}\sim\text{1975}$）：中小规模集成电路。</li><li>第四代（$\text{1975}\sim\texttt{至今}$）：大规模／超大规模集成电路。</li></ol><ul><li>计算机的应用</li></ul><ol><li>科学计算（数值计算）。</li><li>数据处理（信息处理）。</li><li>人工智能。</li><li>自动控制。</li><li>计算机辅助设计和制造：</li></ol><div class="table-container"><table><thead><tr><th style="text-align:left">$\texttt{CAI（计算机辅助教学）}$</th><th style="text-align:left">$\texttt{CAM（计算机辅助制造）}$</th></tr></thead><tbody><tr><td style="text-align:left">$\texttt{CAT（计算机辅助测试）}$</td><td style="text-align:left">$\texttt{CAD（计算机辅助设计）}$</td></tr><tr><td style="text-align:left">$\texttt{CAE（计算机辅助教育）}$</td><td style="text-align:left">$\texttt{CIMS（计算机集成制造系统）}$</td></tr></tbody></table></div><ul><li>计算机的组成</li></ul><ol><li>硬件系统</li></ol><p>五个基本部分组成：运算器，控制器，存储器，输入设备，输出设备。</p><p><img src="https://z3.ax1x.com/2021/09/05/hWLVjs.png" alt=""></p><p>运算器+控制器=CPU（中央处理器），CPU 直接决定计算机的运行速度。</p><p>$\text{Eg}$：$\texttt{Intel奔腾IV2.8GHz/512M/80GB/50X}$，每秒运算次数为 $2.8\times 2^{10}\times 2^{10}\times 2^{10}$。</p><p>存储器分类：</p><p><img src="https://z3.ax1x.com/2021/09/05/hWLz24.png" alt=""></p><p>运行速度比较：</p><p>寄存器 &gt; $\text{Cache}$ &gt; 内存速度 &gt; 外存速度。</p><ol><li>软件系统</li></ol><p>分为 系统软件 与 应用软件。</p><p>系统软件分为 操作系统软件 与 计算机语言。</p><p>操作系统软件：$\color{red}\text{DOS}$，$\color{red}\text{OS/2}$，$\text{windows95}$，$\text{windows98}$，$\text{windows 2000}$，$\text{xp}$，$\text{Vista}$，$\color{red}\text{win7}$，$\text{win8}$，$\color{red}\text{MAC OS}$，$\color{red}\text{Ubuntu}$，$\color{red}\text{win10}$ 等。</p><p>计算机语言可分为 机器语言，汇编语言，高级语言 三大类。</p><p>机器语言：一台计算机全部的指令集合。</p><p>汇编语言：用一些简洁的英文字母、符号串来替代一个特定的指令的二进制串，亦称为 符号语言。</p><p><strong>高级语言</strong>：$\text{BASIC}$，$\text{C}$，$\text{C++}$，$\text{PASCAL}$，$\text{FORTRAN}$。</p><p>应用软件：$\text{Office}$，$\text{3Dmax}$，$\text{Flash}$，$\text{Photoshop}$ 等。</p><p>$\text{Ps}$：只有硬件没有安装软件的计算机称为 $\color{blue}\text{“裸机”}$。</p><p>面向对象语言：是一类<strong>以对象作为基本程序结构单位</strong>的程序设计语言，可分为 纯面向对象语言，混合型面向对象语言。</p><p>纯面向对象语言有 $\text{Smalltalk}$，$\text{EIFFEL}$ 等。</p><p>混合型面向对象语言有 $\text{C++}$，$\text{Objective-C}$ 等。</p><ul><li>计算机指令系统</li></ul><p>指令：计算机能直接识别和执行的命令。</p><p>指令本身是二进制代码。是要计算机执行某种操作的命令。</p><p>用机器指令编写的程序称之为机器语言程序。</p><p>一条指令通常由 $\color{red}\text{操作码}$ 和 $\color{red}\text{地址码}$ 两部分组成。</p><p><img src="https://z3.ax1x.com/2021/09/06/h5iWh4.png" alt=""></p><ul><li>计算机的数字系统</li></ul><p>数值信息在计算机内的表示方法就是用<strong>二进制数</strong>来表示。</p><p>通常有 $\text{10}$ 进制，$\text{2}$ 进制，$\text{8}$ 进制与 $\text{16}$ 进制。</p><ol><li>$\text{10}$ 进制转 $\text{R}$ 进制——短除法。</li></ol><p><img src="https://z3.ax1x.com/2021/09/06/h5Fab6.jpg" alt=""></p><p>如果有小数，则不断乘 $\text{R}$ 且去整数部分正向输出。</p><p>$(0.3125)_{10}$</p><p>$0.3125\times 2=0.625\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,0$</p><p>$0.625\times 2=1.25\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,1$</p><p>$0.25\times 2=0.5\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,0$</p><p>$0.5\times 2=1\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,1$</p><p>所以 $(0.3125)_{10}=(0.0101)_{2}$。</p><ol><li>$\text{R}$ 进制转 $\text{10}$ 进制——按权展开法。</li></ol><p>$(1000101.101)_{2}$</p><p>$1\times 2^{-3}+1\times 2^{-1}+1\times 2^{0}+1\times 2^{2}+1\times 2^{6}=69.625$</p><p>所以 $(1000101.101)_{2}=(69.625)_{10}$。</p><ol><li>特殊：$\text{8}$ 进制转 $\text{16}$ 进制——以二进制为桥梁。</li></ol><p>$\text{8}$ 进制表示数：</p><div class="table-container"><table><thead><tr><th style="text-align:right">$\text{0}$</th><th style="text-align:right">$\text{000}$</th></tr></thead><tbody><tr><td style="text-align:right">$\text{1}$</td><td style="text-align:right">$\text{001}$</td></tr><tr><td style="text-align:right">$\text{2}$</td><td style="text-align:right">$\text{010}$</td></tr><tr><td style="text-align:right">$\text{3}$</td><td style="text-align:right">$\text{011}$</td></tr><tr><td style="text-align:right">$\text{4}$</td><td style="text-align:right">$\text{100}$</td></tr><tr><td style="text-align:right">$\text{5}$</td><td style="text-align:right">$\text{101}$</td></tr><tr><td style="text-align:right">$\text{6}$</td><td style="text-align:right">$\text{110}$</td></tr><tr><td style="text-align:right">$\text{7}$</td><td style="text-align:right">$\text{111}$</td></tr></tbody></table></div><p>将 $\text{8}$ 进制数每位数用 $\text{2}$ 进制数代替后，再转 $\text{16}$ 进制。</p><div class="table-container"><table><thead><tr><th style="text-align:right">$\text{0}$</th><th style="text-align:right">$\text{0000}$</th></tr></thead><tbody><tr><td style="text-align:right">$\text{1}$</td><td style="text-align:right">$\text{0001}$</td></tr><tr><td style="text-align:right">$\text{2}$</td><td style="text-align:right">$\text{0010}$</td></tr><tr><td style="text-align:right">$\text{3}$</td><td style="text-align:right">$\text{0011}$</td></tr><tr><td style="text-align:right">$\text{4}$</td><td style="text-align:right">$\text{0100}$</td></tr><tr><td style="text-align:right">$\text{5}$</td><td style="text-align:right">$\text{0101}$</td></tr><tr><td style="text-align:right">$\text{6}$</td><td style="text-align:right">$\text{0110}$</td></tr><tr><td style="text-align:right">$\text{7}$</td><td style="text-align:right">$\text{0111}$</td></tr><tr><td style="text-align:right">$\text{8}$</td><td style="text-align:right">$\text{1000}$</td></tr><tr><td style="text-align:right">$\text{9}$</td><td style="text-align:right">$\text{1001}$</td></tr><tr><td style="text-align:right">$\text{A}$</td><td style="text-align:right">$\text{1010}$</td></tr><tr><td style="text-align:right">$\text{B}$</td><td style="text-align:right">$\text{1011}$</td></tr><tr><td style="text-align:right">$\text{C}$</td><td style="text-align:right">$\text{1100}$</td></tr><tr><td style="text-align:right">$\text{D}$</td><td style="text-align:right">$\text{1101}$</td></tr><tr><td style="text-align:right">$\text{E}$</td><td style="text-align:right">$\text{1110}$</td></tr><tr><td style="text-align:right">$\text{F}$</td><td style="text-align:right">$\text{1111}$</td></tr></tbody></table></div><p>如 $(567)_{8}$，先转为 $(000101110111)_{2}$，再转为 $(177)_{16}$。</p><p>小数同理。</p><ul><li>计算机中带符号位的表示方法</li></ul><p>原码：符号位为 $\text{0}$ 表示正数，符号位为 $\text{1}$ 表示负数，其余各位表示数值部分。</p><p>反码：</p><p>对于正数，它的反码表示与原码相同。</p><p>对于负数，则除符号位仍为 $\text{“1”}$ 外，其余各位 $\text{“1”}$ 换成 $\text{“0”}$，$\text{“0”}$ 换成 $\text{“1”}$。</p><p>对于 $\text{0}$，它的表示方法有两种，$\text{+0(00000)}$，$\text{-0(10000)}$。</p><p>补码：</p><p>正数的补码就是该正数本身。</p><p>对于负数：符号位不变，将其反码加 $\text{1}$。</p><ul><li>信息存储单位</li></ul><p>常见的有 $\text{bit(b)}$，$\text{Byte(B)}$，$\text{KiB}$，$\text{MiB}$，$\text{GiB}$。</p><p>$\text{1 B=8 b}$。</p><p>$\text{1 KiB=1024 B}$。</p><p>$\text{1 MiB=1024 KiB}$。</p><p>$\text{1 GiB=1024 MiB}$。</p><p>$\texttt{ASCII}$ 码：“美国信息交换标准代码” 的简称，最多可以表示 $\text{128}$ 个不同的符号，即一个字节。</p><p>$\text{‘0’ — 48}$，$\text{‘A’ — 65}$，$\text{‘a’ — 97}$。</p><ul><li>视频文件大小的计算</li></ul><p>例如：</p><p>现有一段 $\text{24}$ 分钟的视频文件，它的帧率是 $\text{30 Hz}$，分辨率是 $1920\times 1080$，每帧图像都是 $\text{32}$ 位真彩色图像，使用的视频编码算法达到了 $\text{25\%}$ 的压缩率。则这个视频文件占用的存储空间大小约是 （ ）。</p><p>$\text{A. 668 GiB}$</p><p>$\text{B. 334 GiB}$</p><p>$\text{C. 85 GiB}$</p><p>$\text{D. 500 GiB}$</p><p>$24\texttt{(24分钟)}\times 60\texttt{(每分钟60秒)}\times 30\texttt{(帧率)}\times 1920\times 1080\texttt{(分辨率)}\times 32\texttt{(32位)}\times 25\%\texttt{(25\%的压缩率)}\div 8\texttt{(1B=8b)}\div 1024\texttt{(1KiB=1024B)}\div 1024\texttt{(1MiB=1024KiB)}\div 1024\texttt{(1GiB=1024MiB)}$，约为 $\text{85 GiB}$，选 $\text{B}$。</p><ul><li>逻辑运算</li></ul><p>有 $\text{and(}\wedge\text{)}$，$\text{or(}\vee \text{)}$，$\text{not(}\neg \text{)}$，$\text{xor(}\oplus \text{)}$。</p><p>运算的优先级：$\text{not}$＞$\text{and}$＞$\text{or}$。</p><p>与运算：如果都为 $1$，则为 $1$，否则为 $0$。</p><p>或运算：如果都为 $0$，则为 $0$，否则为 $1$。</p><p>非运算：如果为 $1$，则为 $0$，否则为 $1$。</p><h2 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2.数据结构"></a>2.数据结构</h2><ul><li>线性表</li></ul><p>概念：线性表是由 $n(n\ge 0)$ 个具有相同特性数据元素（结点） $a_{1}，a_{2}，\cdots，a_{n}$ 组成的有限序列。</p><p>长度：所含元素的个数，用 $n$ 表示，$n\ge ０$。</p><p>$\text{Ps}$：当 $\text{n=0}$ 时,表示线性表是一个空表，即表中不包含任何元素。</p><p>逻辑结构表示图：</p><p><img src="https://z3.ax1x.com/2021/09/08/hbpAWF.png" alt=""></p><p>插入操作：</p><p>在表中下标为 $i$ 的元素 $a_{i}$ 后插入 $x$，后面元素往后移。若 $i=-1$，则将新元素 $x$ 插在最前面。</p><p><img src="https://z3.ax1x.com/2021/09/08/hbp3WD.png" alt=""></p><p>删除操作：</p><p>删除元素 $a_{i}$，后面元素往前移。</p><p><img src="https://z3.ax1x.com/2021/09/08/hbpWT0.png" alt=""></p><ul><li>数组</li></ul><p>概念：有序的元素序列。</p><p><strong>二分查找</strong>：</p><p>框架：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 计算 mid 时需考虑溢出，因此最好写为 mid = left + (right - left) / 2</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写法 $\text{1}$：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左闭右闭式</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>; </span><br><span class="line">    <span class="type">int</span> right = nums.length - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123; <span class="comment">// 注意</span></span><br><span class="line">        <span class="type">int</span> mid = (right + left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写法 $\text{2}$：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左闭右开式找左侧边界</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">left_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = nums.length; <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 注意</span></span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid; <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写法 $\text{3}$：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左闭右开式找右侧边界</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">right_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最坏情况查找 $\left \lceil \log_{2}n \right \rceil$ 次。</p><p><strong>排序</strong></p><p>常考的有：选择排序、冒泡排序、插入排序、快速排序、希尔排序、堆排序、归并排序、基数排序。</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">$\texttt{选择排序}$</th><th style="text-align:center">$\texttt{冒泡排序}$</th><th style="text-align:center">$\texttt{插入排序}$</th><th style="text-align:center">$\texttt{快速排序}$</th><th style="text-align:center">$\texttt{希尔排序}$</th><th style="text-align:center">$\texttt{堆排序}$</th><th style="text-align:center">$\texttt{归并排序}$</th><th style="text-align:center">$\texttt{基数排序}$</th></tr></thead><tbody><tr><td style="text-align:center">$\texttt{平均情况}$</td><td style="text-align:center">$\mathcal{O}(n^{2})$</td><td style="text-align:center">$\mathcal{O}(n^{2})$</td><td style="text-align:center">$\mathcal{O}(n^{2})$</td><td style="text-align:center">$\mathcal{O}(n\log n)$</td><td style="text-align:center">$\mathcal{O}(n^{1.3})$</td><td style="text-align:center">$\mathcal{O}(n\log n)$</td><td style="text-align:center">$\mathcal{O}(n\log n)$</td><td style="text-align:center">$\mathcal{O}(d(n+r))$</td></tr><tr><td style="text-align:center">$\texttt{最坏情况}$</td><td style="text-align:center">$\mathcal{O}(n^{2})$</td><td style="text-align:center">$\mathcal{O}(n^{2})$</td><td style="text-align:center">$\mathcal{O}(n^{2})$</td><td style="text-align:center">$\mathcal{O}(n^{2})$</td><td style="text-align:center"></td><td style="text-align:center">$\mathcal{O}(n\log n)$</td><td style="text-align:center">$\mathcal{O}(n\log n)$</td><td style="text-align:center">$\mathcal{O}(d(n+r))$</td></tr><tr><td style="text-align:center">$\texttt{最好情况}$</td><td style="text-align:center">$\mathcal{O}(n^{2})$</td><td style="text-align:center">$\mathcal{O}(n^{2})$</td><td style="text-align:center">$\mathcal{O}(n^{2})$</td><td style="text-align:center">$\mathcal{O}(n\log n)$</td><td style="text-align:center"></td><td style="text-align:center">$\mathcal{O}(n\log n)$</td><td style="text-align:center">$\mathcal{O}(n\log n)$</td><td style="text-align:center">$\mathcal{O}(d(n+r))$</td></tr><tr><td style="text-align:center">$\texttt{空间复杂度}$</td><td style="text-align:center">$\mathcal{O}(1)$</td><td style="text-align:center">$\mathcal{O}(1)$</td><td style="text-align:center">$\mathcal{O}(1)$</td><td style="text-align:center">$\mathcal{O}(n\log n)$</td><td style="text-align:center">$\mathcal{O}(1)$</td><td style="text-align:center">$\mathcal{O}(1)$</td><td style="text-align:center">$\mathcal{O}(n)$</td><td style="text-align:center">$\mathcal{O}(r)$</td></tr><tr><td style="text-align:center">$\texttt{稳定性}$</td><td style="text-align:center">$\texttt{不稳定}$</td><td style="text-align:center">$\texttt{稳定}$</td><td style="text-align:center">$\texttt{稳定}$</td><td style="text-align:center">$\texttt{不稳定}$</td><td style="text-align:center">$\texttt{不稳定}$</td><td style="text-align:center">$\texttt{不稳定}$</td><td style="text-align:center">$\texttt{稳定}$</td><td style="text-align:center">$\texttt{稳定}$</td></tr></tbody></table></div><ul><li>树</li></ul><p>树是典型的非线性结构，它是由 $n(n\ge 1)$ 个有限节点组成一个具有层次关系的集合。</p><p>常用的树为<strong>二叉树</strong>。</p><p><strong>遍历</strong>：</p><p>先序遍历：根，左，右。</p><p><img src="https://oi-wiki.org/graph/images/tree-basic-Preorder.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preTrav</span><span class="params">(BiTree* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root) &#123;</span><br><span class="line">    cout &lt;&lt; root-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">preTrav</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">preTrav</span>(root-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历：左、根、右。</p><p><img src="https://oi-wiki.org/graph/images/tree-basic-inorder.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">midTrav</span><span class="params">(BiTree* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root) &#123;</span><br><span class="line">    <span class="built_in">midTrav</span>(root-&gt;left);</span><br><span class="line">    cout &lt;&lt; root-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">midTrav</span>(root-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历：左、右、根。</p><p><img src="https://oi-wiki.org/graph/images/tree-basic-Postorder.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lastTrav</span><span class="params">(BiTree* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root) &#123;</span><br><span class="line">    <span class="built_in">lastTrav</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">lastTrav</span>(root-&gt;right);</span><br><span class="line">    cout &lt;&lt; root-&gt;key &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>满二叉树/完美二叉树：所有叶结点的深度均相同的二叉树称为满二叉树/完美二叉树。</p><p>完全二叉树：只有最下面两层结点的度数可以小于 $2$，且最下面一层的结点都集中在该层的最左侧。</p><p><img src="https://oi-wiki.org/graph/images/tree-binary-complete.svg" alt=""></p><p><img src="https://oi-wiki.org/graph/images/tree-binary-perfect.svg" alt=""></p><p>应用：堆排序，<strong>哈夫曼树</strong>。</p><p>算平均查找次数时可画搜索二叉树。</p><p>搜索二叉树是一种特殊有序的二叉树，如果一棵树不为空，并且如果它的根节点左子树不为空，那么它左子树上面的所有节点的值都小于它的根节点的值，如果它的右子树不为空，那么它右子树任意节点的值都大于他的根节点的值，它的左右子树也是二叉搜索树。</p><p>由此可见，如果对二叉搜索树进行中序排列（左中右），那么会得到一个从小到大的序列。</p><p>则将有序序列 $a$ 转为搜索二叉树后，每个结点对应深度即为这个结点所需的查找次数（根节点深度为 $1$ ）。</p><ul><li>栈</li></ul><p>遵循先进后出（$\texttt{DFS}$）。</p><ul><li>队列</li></ul><p>遵循先进先出（$\texttt{BFS}$）。</p><ul><li>图</li></ul><p>图是另一种<strong>非线性</strong>数据结构。在图结构中，数据结点一般称为顶点，而边是顶点的有序偶对。如果两个顶点之间存在一条边，那么就表示这两个顶点具有相邻关系。</p><p>入度：以顶点 $v$ 为终点的边的条数为该节点的入度。</p><p>出度：以顶点 $v$ 为起点的边的条数为该节点的出度。</p><p>分为有向图和无向图。</p><p><img src="https://z3.ax1x.com/2021/09/10/hvBoAx.png" alt=""><br><img src="https://z3.ax1x.com/2021/09/10/hvB5H1.png" alt=""></p><p>最短路算法有 $\color{red}\texttt{Floyd}$，$\color{red}\texttt{Dijkstra}$，$\texttt{Bellman-Ford}$，$\texttt{SPFA}$。</p><ul><li>堆</li></ul><p>算法：堆排序。</p><p>应用：$\text{STL}$ 大根堆——<code>priority_queue &lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;q;</code>。</p><p>$\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,$$\text{STL}$ 小根堆——<code>priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;</code></p><ul><li>链表</li></ul><p>分为单向链表与双向链表。</p><p>$\large\texttt{单向链表}$：</p><p><img src="https://z3.ax1x.com/2021/09/10/hvrki6.jpg" alt=""></p><p>删除节点：</p><p><img src="https://z3.ax1x.com/2021/09/10/hvriIx.jpg" alt=""></p><p>添加结点：</p><p><img src="https://z3.ax1x.com/2021/09/10/hvr3Jf.jpg" alt=""></p><p>$\large\texttt{双向链表}$：</p><p><img src="https://z3.ax1x.com/2021/09/10/hvrgOJ.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双向链表节点结构</span></span><br><span class="line">typedef struct dlink_node</span><br><span class="line">&#123;</span><br><span class="line">    struct dlink_node *prev;</span><br><span class="line">    struct dlink_node *next;</span><br><span class="line">    <span class="keyword">void</span> *val;  <span class="comment">//能存储任意类型数据</span></span><br><span class="line">&#125;node;</span><br></pre></td></tr></table></figure><p>删除结点：</p><p><img src="https://z3.ax1x.com/2021/09/10/hvrWwR.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除节点pindex</span></span><br><span class="line">pindex-&gt;next-&gt;prev = pindex-&gt;prev;</span><br><span class="line">pindex-&gt;prev-&gt;next = pindex-&gt;next;</span><br><span class="line">free(pindex); <span class="comment">//注意释放节点</span></span><br></pre></td></tr></table></figure><p>添加结点：</p><p><img src="https://z3.ax1x.com/2021/09/10/hvrRm9.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将pnode节点插入到pindex之前</span></span><br><span class="line">pnode-&gt;prev = pindex-&gt;prev;</span><br><span class="line">pnode-&gt;next = pindex;</span><br><span class="line">pindex-&gt;prev-&gt;next = pnode;</span><br><span class="line">pindex-&gt;prev = pnode;</span><br></pre></td></tr></table></figure><h2 id="3-数学"><a href="#3-数学" class="headerlink" title="3.数学"></a>3.数学</h2><ul><li><strong>时间复杂度</strong></li></ul><p>定义：在进行算法分析时，语句总的执行次数 $\text{T(n)}$ 是关于问题规模 $n$ 的函数，进而分析 $\text{T(n)}$ 随 $n$ 的变化情况并确定 $\text{T(n)}$ 的数量级。算法的时间复杂度，也就是算法的时间量度，记作：$\text{T(n)=O(f(n))}$。它表示随问题规模 $n$ 的增大，算法执行时间的增长率和 $\text{f(n)}$ 的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中 $\text{f(n)}$ 是问题规模 $n$ 的某个函数。 这样用大写 $\text{O()}$ 来体现算法时间复杂度的记法，我们称之为大 $\text{O}$ 记法。一般情况下，随着 $n$ 的增大，$\text{T(n)}$增长最慢的算法为最优算法。</p><p>符号：</p><p>$\Theta $，可以理解为 $=$。</p><p>$\mathcal{O}$，可以理解为 $\le$。</p><p>$\Omega $，可以理解为 $\ge$。</p><p>$o$，可以理解为 $&lt;$。</p><p>$\omega $，可以理解为 $&gt;$。</p><p><strong>主定理</strong></p><p>$T(n)=aT\left(\frac{n}{b}\right)+f(n)$</p><ol><li>若函数 $n^{\log_{b} a}$ 更大，则 $T(n)=\Theta\left(n^{\log _{b} a}\right)$；</li><li>若函数 $f(n)$ 更大，且满足 $a f(n/b) \leq c f(n)$，则 $T(n)=\Theta(f(n))$；</li><li>若两函数相等，则 $T(n)=\Theta\left(n^{\log _{b} a} \log ^{k+1} n\right)$。</li></ol><p>以上的大小比价, 都是渐进意义上的。</p><p>$\text{Ps}$：第三种情况，大多数时候 $k=0$。</p><p><a href="https://zhuanlan.zhihu.com/p/113406812">https://zhuanlan.zhihu.com/p/113406812</a></p><ul><li>排列组合</li></ul><p>排列英文名叫 $\texttt{Arrangement}$ 或者 $\texttt{Permutation}$，下文统称为 <strong>P</strong>。</p><p>组合英文名叫 $\texttt{Combination}$，下文统称为 <strong>C</strong>。</p><p>$\mathcal{P}_{n}^{m}=\frac{n!}{(n-m)!}=n\times (n-1)\times \dots\times(n-m+1)$</p><p>$\mathcal{C}_{n}^{m}=\frac{n!}{(n-m)!m!}=\frac{n\times (n-1)\times \dots\times(n-m+1)}{m\times (m-1)\times \dots\times 1}$</p><p>组合数规律 $1$：</p><p>$\mathcal{C}_{n}^{m}=\mathcal{C}_{n}^{n-m}$</p><p>组合数规律 $2$：</p><p>$\mathcal{C}_{n}^{m-1}+\mathcal{C}_{n}^{m}=\mathcal{C}_{n+1}^{m}$</p><p>组合数规律 $3$：</p><p>$\mathcal{C}_{n}^{0}+\mathcal{C}_{n}^{1}+\dots+\mathcal{C}_{n}^{n}=2^{n}$</p><p>组合数规律 $4$：</p><p>$\mathcal{C}_{r}^{r}+\mathcal{C}_{r+1}^{r}+\dots+\mathcal{C}_{n}^{r}=\mathcal{C}_{n+1}^{r+1}$</p><p>组合数规律 $5$：</p><p>$\sum_{i=0}^{k} \mathcal{C}_{n}^{i} \mathcal{C}_{m}^{k-i}=\mathcal{C}_{m+n}^{k}$</p><p><strong>经典模型</strong>：</p><p><a href="https://www.luogu.com.cn/blog/chengni5673/dang-xiao-qiu-yu-shang-he-zi">当小球遇上盒子</a></p><p>默认为有 $n$ 个小球，$m$ 个盒子。</p><ol><li>球相同，盒子不同，不能有空盒</li></ol><p>$ans=\mathcal{C}_{n-1}^{m-1}$</p><ol><li>球相同，盒子不同，可以有空盒</li></ol><p>$ans=\mathcal{C}_{n+m-1}^{m-1}$</p><ol><li>球不同，盒子不同，可以有空盒</li></ol><p>$ans=m^{n}$</p><p>其余均有些超纲，有兴趣的同学可以自行阅读链接文章。</p><p>拓展试题：<a href="https://www.luogu.com.cn/problem/P5824">P5824</a>。</p><p>一般 $\begin{pmatrix}<br>n \\<br>m<br>\end{pmatrix}$ 表示组合数，$\begin{bmatrix}<br>n \\<br>m<br>\end{bmatrix}$ 表示第一类斯特林数，$\begin{Bmatrix}<br>n \\<br>m<br>\end{Bmatrix}$ 表示第二类斯特林数。</p><ul><li>其余定理</li></ul><p>推荐阅读：</p><p><a href="https://www.cnblogs.com/Lrefrain/p/11353765.html">https://www.cnblogs.com/Lrefrain/p/11353765.html</a></p><p><del><a href="https://www.luogu.com.cn/blog/BotDand/lucas-xue-xi-bi-ji">https://www.luogu.com.cn/blog/BotDand/lucas-xue-xi-bi-ji</a></del>（<del>推荐自己的，真不要脸</del>）</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>终于咕完了，希望初赛 $\texttt{RP++}$ \kel。</p><h1 id="5-补充"><a href="#5-补充" class="headerlink" title="5. 补充"></a>5. 补充</h1><ul><li>各种数据类型占用的内存空间</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">空间</th></tr></thead><tbody><tr><td style="text-align:center">$\text{int}$</td><td style="text-align:center">$4B$</td></tr><tr><td style="text-align:center">$\text{long long}$</td><td style="text-align:center">$8B$</td></tr><tr><td style="text-align:center">$\text{char}$</td><td style="text-align:center">$1B$</td></tr><tr><td style="text-align:center">$\text{double}$</td><td style="text-align:center">$8B$</td></tr><tr><td style="text-align:center">$\text{bool}$</td><td style="text-align:center">$1B$</td></tr><tr><td style="text-align:center">$\text{float}$</td><td style="text-align:center">$4B$</td></tr><tr><td style="text-align:center">$\text{short}$</td><td style="text-align:center">$2B$</td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> CSP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些稀奇古怪的东西</title>
      <link href="/post/9779baa0.html"/>
      <url>/post/9779baa0.html</url>
      
        <content type="html"><![CDATA[<h2 id="Tabs"><a href="#Tabs" class="headerlink" title="Tabs"></a>Tabs</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab 这样子--&gt;</span><br><span class="line"><span class="strong">**只有名字**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb--&gt;</span><br><span class="line"><span class="strong">**图标加名字**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**默认 Tab**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">这样子</button></li><li class="tab"><button type="button" data-href="#test1-2"><i class="fas fa-bomb"></i>炸弹</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>只有名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>图标加名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>默认 Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% label text color %&#125;</span><br></pre></td></tr></table></figure><ul><li><p>text: 文字</p></li><li><p>color: (可选)背景颜色默认为 default<br>default/blue/pink/red/purple/orange/green</p></li></ul><p>臣亮言：<mark class="hl-label default">先帝</mark> 创业未半，而<mark class="hl-label blue">中道崩殂</mark> 。今天下三分，<mark class="hl-label pink">益州疲敝</mark> ，此诚<mark class="hl-label red">危急存亡之秋</mark> 也！然侍衞之臣，不懈于内；<mark class="hl-label purple">忠志之士</mark> ，忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气；不宜妄自菲薄，引喻失义，以塞忠谏之路也。<br>宫中、府中，俱为一体；陟罚臧否，不宜异同。若有<mark class="hl-label orange">作奸</mark> 、<mark class="hl-label green">犯科</mark> ，及为忠善者，宜付有司，论其刑赏，以昭陛下平明之治；不宜偏私，使内外异法也。</p><h2 id="时间轴"><a href="#时间轴" class="headerlink" title="时间轴"></a>时间轴</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline title,color %&#125;</span><br><span class="line">&lt;!-- timeline title --&gt;</span><br><span class="line">xxxxx</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&lt;!-- timeline title --&gt;</span><br><span class="line">xxxxx</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><ul><li><p>title: 标题/时间线</p></li><li><p>color: timeline 颜色<br>default(留空) / blue / pink / red / purple / orange / green</p></li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 2022 %&#125;</span><br><span class="line">&lt;!-- timeline 8-12 --&gt;</span><br><span class="line">这是测试页面</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><div class="timeline undefined"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2022</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>8-12</p></div></div><div class='timeline-item-content'><p>这是测试页面</p></div></div></div><h2 id="Note-标签"><a href="#Note-标签" class="headerlink" title="Note 标签"></a>Note 标签</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><ul><li><p>class    【可选】标识，不同的标识有不同的配色<br>（ default / primary / success / info / warning / danger ）</p></li><li><p>no-icon 【可选】不显示 icon</p></li><li><p>style 【可选】可以覆盖配置中的 style<br>（simple/modern/flat/disabled）</p></li></ul><blockquote><p>flat（个人比较喜欢这个）</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note flat %&#125;</span><br><span class="line">默认 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default flat %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary flat %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success flat %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info flat %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning flat %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger flat %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note flat"><p>默认 提示块标签</p></div><div class="note default flat"><p>default 提示块标签</p></div><div class="note primary flat"><p>primary 提示块标签</p></div><div class="note success flat"><p>success 提示块标签</p></div><div class="note info flat"><p>info 提示块标签</p></div><div class="note warning flat"><p>warning 提示块标签</p></div><div class="note danger flat"><p>danger 提示块标签</p></div><blockquote><p>simple</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note simple %&#125;</span><br><span class="line">默认 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default simple %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary simple %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success simple %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info simple %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning simple %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger simple %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note simple"><p>默认 提示块标签</p></div><div class="note default simple"><p>default 提示块标签</p></div><div class="note primary simple"><p>primary 提示块标签</p></div><div class="note success simple"><p>success 提示块标签</p></div><div class="note info simple"><p>info 提示块标签</p></div><div class="note warning simple"><p>warning 提示块标签</p></div><div class="note danger simple"><p>danger 提示块标签</p></div><blockquote><p>modern</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note modern %&#125;</span><br><span class="line">默认 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note modern"><p>默认 提示块标签</p></div><div class="note default modern"><p>default 提示块标签</p></div><div class="note primary modern"><p>primary 提示块标签</p></div><div class="note success modern"><p>success 提示块标签</p></div><div class="note info modern"><p>info 提示块标签</p></div><div class="note warning modern"><p>warning 提示块标签</p></div><div class="note danger modern"><p>danger 提示块标签</p></div><blockquote><p>disabled</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note disabled %&#125;</span><br><span class="line">默认 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default disabled %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary disabled %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success disabled %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info disabled %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning disabled %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger disabled %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note disabled"><p>默认 提示块标签</p></div><div class="note default disabled"><p>default 提示块标签</p></div><div class="note primary disabled"><p>primary 提示块标签</p></div><div class="note success disabled"><p>success 提示块标签</p></div><div class="note info disabled"><p>info 提示块标签</p></div><div class="note warning disabled"><p>warning 提示块标签</p></div><div class="note danger disabled"><p>danger 提示块标签</p></div><blockquote><p>no-icon</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;</span><br><span class="line">默认 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default no-icon %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary no-icon %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success no-icon %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info no-icon %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning no-icon %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger no-icon %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="note no-icon flat"><p>默认 提示块标签</p></div><div class="note default no-icon flat"><p>default 提示块标签</p></div><div class="note primary no-icon flat"><p>primary 提示块标签</p></div><div class="note success no-icon flat"><p>success 提示块标签</p></div><div class="note info no-icon flat"><p>info 提示块标签</p></div><div class="note warning no-icon flat"><p>warning 提示块标签</p></div><div class="note danger no-icon flat"><p>danger 提示块标签</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> 杂物 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树形结构 学习笔记</title>
      <link href="/post/57a9c951.html"/>
      <url>/post/57a9c951.html</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p><a href="https://oi-wiki.org/graph/tree-basic/">树基础</a></p><h3 id="存图方式"><a href="#存图方式" class="headerlink" title="存图方式"></a>存图方式</h3><h4 id="texttt-vector-存图"><a href="#texttt-vector-存图" class="headerlink" title="$\texttt{vector}$ 存图"></a>$\texttt{vector}$ 存图</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加单向边 (x,y)</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">g[x].<span class="built_in">push_back</span>(y);</span><br></pre></td></tr></table></figure><h4 id="texttt-vector-遍历"><a href="#texttt-vector-遍历" class="headerlink" title="$\texttt{vector}$ 遍历"></a>$\texttt{vector}$ 遍历</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历与 x 相邻的点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g[x];++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> y=g[x][i];<span class="comment">// 下一个遍历的点</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链式前向星-存图"><a href="#链式前向星-存图" class="headerlink" title="链式前向星 存图"></a>链式前向星 存图</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加单向边 (x,y)，边值为 w</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">arr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to,w,next;</span><br><span class="line">&#125;edge[N];</span><br><span class="line"><span class="type">int</span> head[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    edge[cnt].next=head[x];</span><br><span class="line">    head[x]=cnt;</span><br><span class="line">    edge[cnt].to=y;</span><br><span class="line">    edge[cnt].w=w;<span class="comment">// 存边值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    <span class="built_in">add</span>(x,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链式前向星-遍历"><a href="#链式前向星-遍历" class="headerlink" title="链式前向星 遍历"></a>链式前向星 遍历</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历与 x 相邻的点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=edge[i].next)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> y=edge[i].to;<span class="comment">// 下一个遍历的点</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：画图工具 <a href="https://csacademy.com/app/graph_editor/">CS Academy</a></p><h2 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>树上任意两节点之间最长的简单路径即为树的直径。</strong></p><h3 id="如何求"><a href="#如何求" class="headerlink" title="如何求"></a>如何求</h3><p>一个做法是两遍 $\texttt{DFS}$，还有一个做法是树形 $\texttt{DP}$。</p><h4 id="两遍-texttt-DFS"><a href="#两遍-texttt-DFS" class="headerlink" title="两遍 $\texttt{DFS}$"></a>两遍 $\texttt{DFS}$</h4><p>首先从任意节点 $x$ 开始 $\texttt{DFS}$，到达距离其最远的节点，记为 $y$。</p><p>再从 $y$ 开始 $\texttt{DFS}$，到达距离其最远的节点，记为 $z$。</p><p>可以知道 $y,z$，即为直径的两端点。</p><p>证明与树形 $\texttt{DP}$ 方法见 <a href="https://oi-wiki.org/graph/tree-diameter/">OI Wiki</a>。</p><div class="note warning flat"><p>两遍 $\texttt{DFS}$ 不能处理负权图。  </p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[k]&gt;ma)</span><br><span class="line">    &#123;</span><br><span class="line">        ma=d[k];</span><br><span class="line">        am=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g[k].<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(g[k][i]==fa) <span class="keyword">continue</span>;</span><br><span class="line">        d[g[k][i]]=d[k]+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(g[k][i],k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[k]&gt;ma)</span><br><span class="line">    &#123;</span><br><span class="line">        ma=d[k];</span><br><span class="line">        am=k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g[k].<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(g[k][i]==fa) <span class="keyword">continue</span>;</span><br><span class="line">        d[g[k][i]]=d[k]+<span class="number">1</span>;</span><br><span class="line">        f[g[k][i]]=k;</span><br><span class="line">        <span class="built_in">dfs2</span>(g[k][i],k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);<span class="comment">// 从节点 1 开始 DFS</span></span><br><span class="line">    <span class="built_in">dfs2</span>(am,<span class="number">0</span>);<span class="comment">// 从搜到的节点开始 DFS</span></span><br><span class="line">    <span class="comment">// am 就是直径的一个端点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>最近公共祖先简称 LCA（Lowest Common Ancestor）。两个节点的最近公共祖先，就是这两个点的公共祖先里面，离根最远的那个。<br>为了方便，我们记某点集 $S=\{v_1,v_2,\ldots,v_n\}$ 的最近公共祖先为 $\text{LCA}(v_1,v_2,\ldots,v_n)$ 或 $\text{LCA}(S)$。</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol><li>$\text{LCA}(\{u\})=u$；</li><li>$u$ 是 $v$ 的祖先，当且仅当 $\text{LCA}(u,v)=u$；</li><li>如果 $u$ 不为 $v$ 的祖先并且 $v$ 不为 $u$ 的祖先，那么 $u,v$ 分别处于 $\text{LCA}(u,v)$ 的两棵不同子树中；</li><li>前序遍历中，$\text{LCA}(S)$ 出现在所有 $S$ 中元素之前，后序遍历中 $\text{LCA}(S)$ 则出现在所有 $S$ 中元素之后；</li><li>两点集并的最近公共祖先为两点集分别的最近公共祖先的最近公共祖先，即 $\text{LCA}(A\cup B)=\text{LCA}(\text{LCA}(A), \text{LCA}(B))$；</li><li>两点的最近公共祖先必定处在树上两点间的最短路上；</li><li>$d(u,v)=h(u)+h(v)-2h(\text{LCA}(u,v))$，其中 $d$ 是树上两点间的距离，$h$ 代表某点到树根的距离。</li></ol><h3 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h3><p>首先可以想到让深度大的那个点先往上跳，直到两点深度相同，再同时往上跳，显然在一颗树上，两点必定相遇。</p><p>复杂度为 $O(n)$。</p><p>但这样复杂度显然不优，考虑优化。</p><p>可以考虑倍增，预处理 $\text{fa}_{x,i}$ 数组，表示点 $x$ 的第 $2^{i}$ 个祖先。</p><p>可以通过 $\texttt{DFS}$ 预处理。</p><p>在向上跳的过程中，因为要先将 $u,v$ 两点跳到深度相同的位置，可以先计算出 $u,v$ 两点的深度差，深度在 $\texttt{DFS}$ 的过程中也能预处理出来。设深度差为 $y$，通过将 $y$ 进行二进制拆分，我们将跳的次数转换为 「$y$ 的二进制表示所含 <code>1</code> 的个数」。</p><p>同时往上跳的过程中，我们从最大的 $i$ 开始循环尝试，一直尝试到 $0$（包括 $0$），如果  $\text{fa}_{u,i}\not=\text{fa}_{v,i}$，则 $u\gets\text{fa}_{u,i},v\gets\text{fa}_{v,i}$，那么最后的 LCA 为 $\text{fa}_{u,0}$。</p><p>倍增算法的预处理时间复杂度为 $O(n \log n)$，单次查询时间复杂度为 $O(\log n)$。</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.luogu.com.cn/problem/P3379">【模板】最近公共祖先</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[<span class="number">500002</span>];</span><br><span class="line"><span class="type">int</span> n,m,s;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="type">int</span> f[<span class="number">500002</span>][<span class="number">22</span>];</span><br><span class="line"><span class="type">int</span> d[<span class="number">500002</span>];</span><br><span class="line"><span class="type">int</span> lg[<span class="number">500002</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[k][<span class="number">0</span>]=fa;</span><br><span class="line">    d[k]=d[fa]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lg[d[k]];++i) f[k][i]=f[f[k][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g[k].<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(g[k][i]==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(g[k][i],k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[x]&lt;d[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">while</span>(d[x]&gt;d[y]) x=f[x][lg[d[x]-d[y]]<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=lg[d[x]]<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i) <span class="keyword">if</span>(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        g[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        g[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) lg[i]=lg[i<span class="number">-1</span>]+(<span class="number">1</span>&lt;&lt;lg[i<span class="number">-1</span>]==i);</span><br><span class="line">    <span class="built_in">dfs</span>(s,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">LCA</span>(x,y)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P3128">Max Flow P</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 考虑差分</span></span><br><span class="line"><span class="comment">// 树上区间 [x,y] 都加 1</span></span><br><span class="line"><span class="comment">// 相当于 sum[x]+1,sum[y]+1,sum[lca(x,y)]-2</span></span><br><span class="line"><span class="comment">// 但 lca(x,y) 上 +2 又 -2 相当于没变，考虑将 sum[fa[lca(x,y)]]-1</span></span><br><span class="line"><span class="comment">// fa[x] 表示 x 的父节点</span></span><br><span class="line"><span class="comment">// 于是变成了 sum[x]+1,sum[y]+1,sum[lca(x,y)]-1,sum[fa[lca(x,y)]]-1</span></span><br><span class="line"><span class="comment">// 用倍增求 LCA</span></span><br><span class="line"><span class="comment">// 遍历整棵树统计和即可</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[<span class="number">50002</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">int</span> sum[<span class="number">50002</span>];</span><br><span class="line"><span class="type">int</span> lg[<span class="number">50002</span>],f[<span class="number">50002</span>][<span class="number">32</span>];</span><br><span class="line"><span class="type">int</span> d[<span class="number">50002</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[k][<span class="number">0</span>]=fa;</span><br><span class="line">    d[k]=d[fa]+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lg[d[k]];++i) f[k][i]=f[f[k][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g[k].<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(g[k][i]==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(g[k][i],k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[x]&lt;d[y]) <span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">while</span>(d[x]&gt;d[y]) x=f[x][lg[d[x]-d[y]]<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=lg[d[x]]<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i) <span class="keyword">if</span>(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g[k].<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(g[k][i]==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">get</span>(g[k][i],k);</span><br><span class="line">        sum[k]+=sum[g[k][i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        g[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        g[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) lg[i]=lg[i<span class="number">-1</span>]+(<span class="number">1</span>&lt;&lt;lg[i<span class="number">-1</span>]==i);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="type">int</span> lca=<span class="built_in">LCA</span>(x,y);</span><br><span class="line">        sum[x]++;</span><br><span class="line">        sum[y]++;</span><br><span class="line">        sum[lca]--;</span><br><span class="line">        sum[f[lca][<span class="number">0</span>]]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">get</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) ans=<span class="built_in">max</span>(ans,sum[i]);</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>对于树上的每一个点，计算其所有子树中最大的子树节点数，这个值最小的点就是这棵树的重心。</p><p>（这里以及下文中的“子树”都是指无根树的子树，即包括“向上”的那棵子树，并且不包括整棵树自身。）</p><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><p>以树的重心为根时，所有子树的大小都不超过整棵树大小的一半。</p><p>树中所有点到某个点的距离和中，到重心的距离和是最小的；如果有两个重心，那么到它们的距离和一样。</p><p>把两棵树通过一条边相连得到一棵新的树，那么新的树的重心在连接原来两棵树的重心的路径上。</p><p>在一棵树上添加或删除一个叶子，那么它的重心最多只移动一条边的距离。</p><h3 id="求法-1"><a href="#求法-1" class="headerlink" title="求法"></a>求法</h3><p>在 $\texttt{DFS}$ 中计算每个子树的大小，记录“<strong>向下</strong>”的子树的最大大小，利用总点数 - 当前子树（这里的子树指<strong>有根树</strong>的子树）的大小得到“<strong>向上</strong>”的子树的大小，然后就可以依据定义找到重心了。</p><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p><a href="http://poj.org/problem?id=1655">【模板】Balancing Act</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf=<span class="number">1e8</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[<span class="number">20002</span>];</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="type">int</span> ans1,ans2;</span><br><span class="line"><span class="type">int</span> siz[<span class="number">20002</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> maxs=-inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g[k].<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(g[k][i]==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(g[k][i],k);</span><br><span class="line">        siz[k]+=siz[g[k][i]]+<span class="number">1</span>;</span><br><span class="line">        maxs=<span class="built_in">max</span>(maxs,siz[g[k][i]]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    maxs=<span class="built_in">max</span>(maxs,n-siz[k]<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(maxs&lt;ans2)</span><br><span class="line">    &#123;</span><br><span class="line">        ans1=k;</span><br><span class="line">        ans2=maxs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(maxs==ans2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k&lt;ans1)</span><br><span class="line">            &#123;</span><br><span class="line">                ans1=k;</span><br><span class="line">                ans2=maxs;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">20000</span>;++i) g[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">memset</span>(siz,<span class="number">0</span>,<span class="built_in">sizeof</span>(siz));</span><br><span class="line">    ans1=<span class="number">0</span>;</span><br><span class="line">    ans2=inf;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        g[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        g[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;ans1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans2&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--) <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note info flat"><p>有一个引理：对于一颗以 $u$ 为根的子树，如果 $u$ 不是子树的重心，那么重心一定在 $u$ 的重儿子的子树里面。也就是说，如果 $u$ 不是自己的子树的重心，那么<strong>重心的方向我们是完全可以确定的</strong>。</p><p>于是可以考虑倍增优化，时间复杂度降为 $O(\log n)$。</p></div><p><a href="https://www.luogu.com.cn/problem/P5666">[CSP-S2019] 树的重心</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[<span class="number">300002</span>];</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="type">int</span> f[<span class="number">300002</span>],F[<span class="number">300002</span>];</span><br><span class="line"><span class="type">int</span> son[<span class="number">300002</span>],son2[<span class="number">300002</span>],son3[<span class="number">300002</span>];</span><br><span class="line"><span class="type">int</span> so[<span class="number">300002</span>][<span class="number">22</span>];</span><br><span class="line"><span class="type">int</span> siz[<span class="number">300002</span>],siz2[<span class="number">300002</span>];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)w=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">max</span>(siz2[son3[k]],s-siz2[k])&lt;=s/<span class="number">2</span>) <span class="keyword">return</span> k;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    siz[k]=<span class="number">1</span>;</span><br><span class="line">    f[k]=fa;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g[k].<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(g[k][i]==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(g[k][i],k);</span><br><span class="line">        siz[k]+=siz[g[k][i]];</span><br><span class="line">        <span class="keyword">if</span>(siz[g[k][i]]&gt;siz[son[k]]) son2[k]=son[k],son[k]=g[k][i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(siz[g[k][i]]&gt;siz[son2[k]]) son2[k]=g[k][i];</span><br><span class="line">    &#125;</span><br><span class="line">    so[k][<span class="number">0</span>]=son[k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">17</span>;++i) so[k][i]=so[so[k][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;g[k].<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(g[k][i]==fa) <span class="keyword">continue</span>;</span><br><span class="line">        siz2[k]=siz[<span class="number">1</span>]-siz[g[k][i]];</span><br><span class="line">        F[k]=<span class="number">0</span>;F[g[k][i]]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[k]==g[k][i]) son3[k]=son2[k];</span><br><span class="line">            <span class="keyword">else</span> son3[k]=son[k];</span><br><span class="line">        <span class="keyword">if</span>(siz2[fa]&gt;siz2[son3[k]]) son3[k]=fa;</span><br><span class="line">        so[k][<span class="number">0</span>]=son3[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">17</span>;++j) so[k][j]=so[so[k][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">        <span class="type">int</span> l=k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">17</span>;j&gt;=<span class="number">0</span>;--j) <span class="keyword">if</span>(siz2[k]-siz2[so[l][j]]&lt;=siz2[k]/<span class="number">2</span>) l=so[l][j];</span><br><span class="line">        ans+=<span class="built_in">sum</span>(son3[l],siz2[k])+<span class="built_in">sum</span>(l,siz2[k])+<span class="built_in">sum</span>(F[l],siz2[k]);</span><br><span class="line">        l=g[k][i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">17</span>;j&gt;=<span class="number">0</span>;--j) <span class="keyword">if</span>(siz2[g[k][i]]-siz2[so[l][j]]&lt;=siz2[g[k][i]]/<span class="number">2</span>) l=so[l][j];</span><br><span class="line">        ans+=<span class="built_in">sum</span>(son3[l],siz2[g[k][i]])+<span class="built_in">sum</span>(l,siz2[g[k][i]])+<span class="built_in">sum</span>(F[l],siz2[g[k][i]]);</span><br><span class="line">        F[k]=g[k][i];</span><br><span class="line">        <span class="built_in">dfs2</span>(g[k][i],k);</span><br><span class="line">    &#125;</span><br><span class="line">    son3[k]=so[k][<span class="number">0</span>]=son[k];</span><br><span class="line">    F[k]=f[k];</span><br><span class="line">    siz2[k]=siz[k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">17</span>;++i) so[k][i]=so[so[k][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">memset</span>(son,<span class="number">0</span>,<span class="built_in">sizeof</span>(son));</span><br><span class="line">    <span class="built_in">memset</span>(son2,<span class="number">0</span>,<span class="built_in">sizeof</span>(son2));</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">300000</span>;++i) g[i].<span class="built_in">clear</span>();</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="built_in">read</span>();y=<span class="built_in">read</span>();</span><br><span class="line">        g[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        g[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(siz2,siz,<span class="built_in">sizeof</span>(siz2));</span><br><span class="line">    <span class="built_in">memcpy</span>(son3,son,<span class="built_in">sizeof</span>(son3));</span><br><span class="line">    <span class="built_in">memcpy</span>(F,f,<span class="built_in">sizeof</span>(F));</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--) <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>参考资料：</p><p><a href="https://oi-wiki.org/graph/tree-diameter">https://oi-wiki.org/graph/tree-diameter</a></p><p><a href="https://oi-wiki.org/graph/lca">https://oi-wiki.org/graph/lca</a></p><p><a href="https://oi-wiki.org/graph/tree-centroid">https://oi-wiki.org/graph/tree-centroid</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵乘法 学习笔记</title>
      <link href="/post/13ab9d87.html"/>
      <url>/post/13ab9d87.html</url>
      
        <content type="html"><![CDATA[<h2 id="0-前置知识"><a href="#0-前置知识" class="headerlink" title="0.前置知识"></a>0.前置知识</h2><p>无</p><h2 id="1-矩阵"><a href="#1-矩阵" class="headerlink" title="1.矩阵"></a>1.矩阵</h2><p>矩阵乘法即为两个矩阵相乘。</p><p>矩阵长这样：<br>$\begin{bmatrix}<br> a_{1,1} &amp; \dots  &amp; a_{1,m}\\<br> \vdots   &amp; \ddots  &amp; \vdots \\<br> a_{n,1} &amp; \dots  &amp; a_{n,m}<br>\end{bmatrix}$</p><p>矩阵乘法需要满足的条件为两个分别为 $n \times k$，$k \times m$的矩阵相乘。</p><p>单元矩阵为对角线为 $1$ 的矩阵，就是数字中的 $1$。</p><h2 id="2-矩阵运算"><a href="#2-矩阵运算" class="headerlink" title="2.矩阵运算"></a>2.矩阵运算</h2><h3 id="1-加法"><a href="#1-加法" class="headerlink" title="1.加法"></a>1.加法</h3><p>令<br>$A=<br>\begin{bmatrix}<br> 2 &amp; 3 &amp; 1\\<br> 1 &amp; 4 &amp; 2<br>\end{bmatrix}$，$<br>B=\begin{bmatrix}<br> 4 &amp; 3 &amp; 2\\<br> 2 &amp; 3 &amp; 2<br>\end{bmatrix}$，则<br>$A+B=\begin{bmatrix}<br> 2+4 &amp; 3+3 &amp; 1+2\\<br> 1+2 &amp; 4+3 &amp; 2+2<br>\end{bmatrix}=\begin{bmatrix}<br> 6 &amp; 6 &amp; 3\\<br> 3 &amp; 7 &amp; 4<br>\end{bmatrix}$</p><h3 id="2-减法"><a href="#2-减法" class="headerlink" title="2.减法"></a>2.减法</h3><p>令<br>$A=<br>\begin{bmatrix}<br> 4 &amp; 3 &amp; 2\\<br> 2 &amp; 4 &amp; 2<br>\end{bmatrix}$，$<br>B=<br>\begin{bmatrix}<br> 2 &amp; 3 &amp; 1\\<br> 1 &amp; 3 &amp; 2<br>\end{bmatrix}$，则<br>$A-B=\begin{bmatrix}<br> 4-2 &amp; 3-3 &amp; 2-1\\<br> 2-1 &amp; 4-3 &amp; 2-2<br>\end{bmatrix}=\begin{bmatrix}<br> 2 &amp; 0 &amp; 1\\<br> 1 &amp; 1 &amp; 0<br>\end{bmatrix}$</p><h3 id="3-数乘"><a href="#3-数乘" class="headerlink" title="3.数乘"></a>3.数乘</h3><p>令<br>$A=<br>\begin{bmatrix}<br> 4 &amp; 3 &amp; 2\\<br> 2 &amp; 4 &amp; 2<br>\end{bmatrix}$，则<br>$2 \times A=<br>\begin{bmatrix}<br> 2 \times 4 &amp; 2 \times 3 &amp; 2 \times 2\\<br> 2 \times 2 &amp; 2 \times 4 &amp; 2 \times 2<br>\end{bmatrix}=<br>\begin{bmatrix}<br> 8 &amp; 6 &amp; 4\\<br> 4 &amp; 8 &amp; 4<br>\end{bmatrix}$</p><h3 id="4-乘法"><a href="#4-乘法" class="headerlink" title="4.乘法"></a>4.乘法</h3><p>设 $A$ 为一个 $n \times k$ 的矩阵，$B$ 为一个 $k \times m$ 的矩阵。</p><p>则 $A$ 与 $B$ 的乘积 $C$ 为一个 $n \times m$的矩阵，且满足$C_{i,j}=\sum_{r=1}^kA_{i,r} \times B_{r,j}$</p><p>举个例子，$A=<br>\begin{bmatrix}<br> 1 &amp; 2 &amp; 2\\<br> 1 &amp; 3 &amp; 2<br>\end{bmatrix}$，$<br>B=<br>\begin{bmatrix}<br> 1 &amp; 0 \\<br> 2 &amp; 2 \\<br> 1 &amp; 1<br>\end{bmatrix}$，则 $A \times B=<br>\begin{bmatrix}<br> 1 \times 1+2 \times 2+2 \times 1 &amp; 1 \times 0+2 \times 2+2 \times 1\\<br> 1 \times 1+3 \times 2+2 \times 1 &amp; 1 \times 0+3 \times 2+2 \times 1<br>\end{bmatrix}=<br>\begin{bmatrix}<br> 7 &amp; 6 \\<br> 9 &amp; 8<br>\end{bmatrix}<br>$</p><h3 id="5-快速幂"><a href="#5-快速幂" class="headerlink" title="5.快速幂"></a>5.快速幂</h3><p>就是快速幂将普通乘法改为矩阵乘法即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&amp;<span class="number">1</span>) ans=ans*a;</span><br><span class="line">    a=a*a;n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还要重定义 <code>*</code> 运算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">arr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">102</span>][<span class="number">102</span>];</span><br><span class="line">    <span class="built_in">arr</span>() &#123;<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));&#125;</span><br><span class="line">    arr <span class="keyword">operator</span> *(<span class="type">const</span> arr &amp;b) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        arr c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=K;++j)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=M;++k)</span><br><span class="line">                    c.a[i][j]=(c.a[i][j]+a[i][k]*b.a[k][j]%mo)%mo;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a,ans;</span><br></pre></td></tr></table></figure><p>就可以运算了。</p><p>模板题：P3390。</p><h2 id="3-应用"><a href="#3-应用" class="headerlink" title="3.应用"></a>3.应用</h2><p>可以快速求除斐波那契数列的第 $n$ 项。</p><p>设 $<br>\begin{bmatrix}<br> f_{n-1} &amp; f_{n-2}<br>\end{bmatrix} \times<br>\begin{bmatrix}<br> a &amp; b \\<br> c &amp; d<br>\end{bmatrix}=<br>\begin{bmatrix}<br> f_{n} &amp; f_{n-1}<br>\end{bmatrix}$</p><p>则 $\begin{bmatrix}<br> f_{n-1} \times a+f_{n-2} \times c &amp; f_{n-1} \times b+f_{n-2} \times d<br>\end{bmatrix}=<br>\begin{bmatrix}<br> f_{n} &amp; f_{n-1}<br>\end{bmatrix}$</p><p>所以 $\left\{\begin{matrix} f_{n-1} \times a+f_{n-2} \times c=f_{n} \\ f_{n-1} \times b+f_{n-2} \times d=f_{n-1}\end{matrix}\right.$</p><p>因为 $f_{n}=f_{n-1}+f_{n-2}$</p><p>解得 $\left\{\begin{matrix}a=1 \\b=1 \\c=1 \\d=0\end{matrix}\right.$</p><p>所以 $<br>\begin{bmatrix}<br> f_{n-1} &amp; f_{n-2}<br>\end{bmatrix} \times<br>\begin{bmatrix}<br> 1 &amp; 1 \\<br> 1 &amp; 0<br>\end{bmatrix}=<br>\begin{bmatrix}<br> f_{n} &amp; f_{n-1}<br>\end{bmatrix}$</p><p>进一步转换得 $<br>\begin{bmatrix}<br> f_{2} &amp; f_{1}<br>\end{bmatrix} \times<br>\begin{bmatrix}<br> 1 &amp; 1 \\<br> 1 &amp; 0<br>\end{bmatrix}^{n-2}=<br>\begin{bmatrix}<br> f_{n} &amp; f_{n-1}<br>\end{bmatrix}$</p><p>所以这玩意就可以用快速幂做了，复杂度为$O(\log_{2}n)$。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>挺玄学的算法。</p><p>练习题：</p><p>P1962</p><p>P1349</p><p>P1306</p><p>P4834</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树 学习笔记</title>
      <link href="/post/bf8e9a46.html"/>
      <url>/post/bf8e9a46.html</url>
      
        <content type="html"><![CDATA[<h2 id="0-前置知识"><a href="#0-前置知识" class="headerlink" title="0.前置知识"></a>0.前置知识</h2><h3 id="1-什么是线段树"><a href="#1-什么是线段树" class="headerlink" title="1.什么是线段树"></a>1.什么是线段树</h3><p>线段树，是一种 <strong>二叉搜索树</strong> 。它将一段区间划分为若干 <strong>单位区间</strong>，每一个节点都储存着一个区间。它功能强大，支持区间求和，区间最大值，区间修改，单点修改等操作。</p><p>线段树的每个节点都存储的一段区间 $[l,r]$，如果是叶子节点，则 $l=r$。</p><p>它的大致思想是：将一段大区间平均地划分成 $2$ 个小区间，每一个小区间都再平均分成 $2$ 个更小区间，直到一个区间的 $l=r$ 才停止。</p><h3 id="2-它能干什么"><a href="#2-它能干什么" class="headerlink" title="2. 它能干什么"></a>2. 它能干什么</h3><p>像上文所说，它能支持区间求和，区间最大值的查询等，换句话说，它能支持的操作能使得区间 $[l,r]$ 可以由 $[l,mid]$ 和 $[mid+1,r]$ 的答案合并得到。</p><p>如区间众数的查询这类问题就不满足该条件。</p><h2 id="1-建树"><a href="#1-建树" class="headerlink" title="1.建树"></a>1.建树</h2><p>通过它的思想可知，每次将一个区间 $[l,r]$ 分为两个小区间 $\bigg[l,\left \lfloor \frac{l+r}{2} \right \rfloor \bigg]$，$\bigg[\left \lfloor \frac{l+r}{2} \right \rfloor +1,r\bigg]$ 进行维护，直到 $l=r$。</p><p>如一颗 $[1,10]$ 的线段树的维护过程（图片来自<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%AE%B5%E6%A0%91/10983506?fr=aladdin">百度百科</a>）</p><p><img src="https://s1.ax1x.com/2022/08/04/vewyGj.png" alt=""></p><p>存储方法通常是<strong>堆式储存法</strong>，节点 $k$ 的左儿子为 $2\times k$，右儿子为 $2\times k+1$，表示区间 $[l,r]$。</p><p>$\texttt{Ps}$：线段树要开 $4 \sim 8$ 倍空间。</p><p>下文代码均为区间求和与区间加操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">arr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> sum;<span class="comment">// 维护区间和</span></span><br><span class="line">&#125;tree[<span class="number">400002</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[k].sum=tree[k*<span class="number">2</span>].sum+tree[k*<span class="number">2</span>+<span class="number">1</span>].sum;</span><br><span class="line">    <span class="comment">// 该区间的和等于子区间的和</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"><span class="comment">// k 表示节点数，l 和 r 表示当前的左右边界</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[k].l=l;tree[k].r=r;<span class="comment">// 存储区间 [l,r]</span></span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="comment">//如果是叶节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree[k].sum=a[l];<span class="comment">// a 数组表示给定的初始数组</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(k*<span class="number">2</span>,l,mid);<span class="built_in">build</span>(k*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);<span class="comment">// 递归左右儿子建树</span></span><br><span class="line">    <span class="built_in">update</span>(k);<span class="comment">// 用左右儿子的值更新当前节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-区间修改"><a href="#2-区间修改" class="headerlink" title="2.区间修改"></a>2.区间修改</h2><p>可以借助图片理解。</p><ol><li>修改区间与当前区间的左右区间均有交集；</li></ol><p><img src="https://s1.ax1x.com/2022/08/04/veB19H.png" alt=""></p><p>可以将修改区间也对半分，然后递归左右区间实现修改操作。</p><p><img src="https://s1.ax1x.com/2022/08/04/veBYut.png" alt=""></p><ol><li>修改区间仅与当前区间的左区间有交集；</li></ol><p><img src="https://s1.ax1x.com/2022/08/04/veBBCQ.png" alt=""></p><p>这时候不用管右区间，直接递归左区间实现修改操作。</p><ol><li>修改区间仅与当前区间的右区间有交集；</li></ol><p><img src="https://s1.ax1x.com/2022/08/04/veBD3j.png" alt=""></p><p>同理，只递归右区间即可。</p><ol><li>修改区间与当前区间重合；</li></ol><p><img src="https://s1.ax1x.com/2022/08/04/veBLVK.png" alt=""></p><p>当前区间的 $\text{sum}$ 加上 $(r-l+1)\times x$，其中 $x$ 为区间加的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 搜到节点 k，修改的区间为 [l,r]，区间加 x</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[k].l==l&amp;&amp;tree[k].r==r)<span class="comment">// 情况 4</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree[k].sum+=(r-l+<span class="number">1</span>)*x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(tree[k].l+tree[k].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) <span class="built_in">change</span>(k*<span class="number">2</span>,l,r,x);<span class="comment">// 情况 2</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) <span class="built_in">change</span>(k*<span class="number">2</span>+<span class="number">1</span>,l,r,x);<span class="comment">// 情况 3</span></span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">change</span>(k*<span class="number">2</span>,l,mid,x),<span class="built_in">change</span>(k*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r,x);<span class="comment">// 情况 4</span></span><br><span class="line">    <span class="built_in">update</span>(k);<span class="comment">// 别忘了更新当前区间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-区间查询"><a href="#3-区间查询" class="headerlink" title="3.区间查询"></a>3.区间查询</h2><p>与区间修改类似。</p><ol><li>查询区间如果与当前区间重合，则直接返回当前区间的 $\text{sum}$ 值。</li><li>查询区间如果仅与当前区间的左区间有交集，则返回递归左区间的值。</li><li>查询区间如果仅与当前区间的右区间有交集，则返回递归右区间的值。</li><li>查询区间如果与当前区间的左右区间均有交集，则返回递归左右区间的值的和。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 搜到节点 k，查询的区间为 [l,r] </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[k].l==l&amp;&amp;tree[k].r==r) <span class="keyword">return</span> tree[k].sum;<span class="comment">// 情况 1 </span></span><br><span class="line">    <span class="type">int</span> mid=(tree[k].l+tree[k].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> <span class="built_in">query</span>(k*<span class="number">2</span>,l,r);<span class="comment">// 情况 2 </span></span><br><span class="line">    <span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> <span class="built_in">query</span>(k*<span class="number">2</span>+<span class="number">1</span>,l,r);<span class="comment">// 情况 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(k*<span class="number">2</span>,l,mid)+<span class="built_in">query</span>(k*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);<span class="comment">// 情况 4 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-懒标记"><a href="#4-懒标记" class="headerlink" title="4.懒标记"></a>4.懒标记</h2><p>如果只是这样暴力修改与查询，复杂度甚至比朴素暴力还要高。</p><p>可以引入懒标记，在每次修改时假装已经给儿子节点修改，在每次查询操作时再下放。</p><p>举个例子，在将区间 $[1,5]$ 加 $3$ 时，可以给区间 $[1,5]$ 的 $\text{lazy}$ 标记上先加 $3$，在查询 $[1,3]$ 的区间和时再给其区间和加上 $(3-1+1)\times 3$。</p><p>注意在修改时也应先下传懒标记。</p><p><img src="https://s1.ax1x.com/2022/08/04/vewyGj.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 下传 k 节点的懒标记</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tree[k].lazy) <span class="keyword">return</span>;<span class="comment">// 如果没有懒标记则不用下传 </span></span><br><span class="line">    <span class="keyword">if</span>(tree[k].l==tree[k].r)<span class="comment">// 如果是叶节点则不用下传 </span></span><br><span class="line">    &#123;</span><br><span class="line">        tree[k].lazy=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tree[k*<span class="number">2</span>].sum+=(tree[k*<span class="number">2</span>].r-tree[k*<span class="number">2</span>].l+<span class="number">1</span>)*tree[k].lazy;</span><br><span class="line">    tree[k*<span class="number">2</span>+<span class="number">1</span>].sum+=(tree[k*<span class="number">2</span>+<span class="number">1</span>].r-tree[k*<span class="number">2</span>+<span class="number">1</span>].l+<span class="number">1</span>)*tree[k].lazy;</span><br><span class="line">    <span class="comment">// 左右节点的区间和加上该节点懒标记</span></span><br><span class="line">    tree[k*<span class="number">2</span>].lazy+=tree[k].lazy;</span><br><span class="line">    tree[k*<span class="number">2</span>+<span class="number">1</span>].lazy+=tree[k].lazy;</span><br><span class="line">    <span class="comment">// 左右节点的懒标记加上该节点的懒标记 </span></span><br><span class="line">    tree[k].lazy=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 该节点的懒标记清空 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-习题"><a href="#5-习题" class="headerlink" title="5.习题"></a>5.习题</h2><p><a href="https://www.luogu.com.cn/problem/P3372">模板 $1$</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">arr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r,sum,lazy;</span><br><span class="line">&#125;tree[<span class="number">400002</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100002</span>];</span><br><span class="line"><span class="type">int</span> x,l,r,k;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[k].l==tree[k].r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[k].lazy=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tree[k*<span class="number">2</span>].sum+=(tree[k*<span class="number">2</span>].r-tree[k*<span class="number">2</span>].l+<span class="number">1</span>)*tree[k].lazy;</span><br><span class="line">    tree[k*<span class="number">2</span>+<span class="number">1</span>].sum+=(tree[k*<span class="number">2</span>+<span class="number">1</span>].r-tree[k*<span class="number">2</span>+<span class="number">1</span>].l+<span class="number">1</span>)*tree[k].lazy;</span><br><span class="line">    tree[k*<span class="number">2</span>].lazy+=tree[k].lazy;</span><br><span class="line">    tree[k*<span class="number">2</span>+<span class="number">1</span>].lazy+=tree[k].lazy;</span><br><span class="line">    tree[k].lazy=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[k].l=l;tree[k].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[k].sum=a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(k*<span class="number">2</span>,l,mid);<span class="built_in">build</span>(k*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    tree[k].sum=tree[k*<span class="number">2</span>].sum+tree[k*<span class="number">2</span>+<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[k].l==l&amp;&amp;tree[k].r==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[k].sum+=x*(r-l+<span class="number">1</span>);</span><br><span class="line">        tree[k].lazy+=x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid=(tree[k].l+tree[k].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) <span class="built_in">change</span>(k*<span class="number">2</span>,l,r,x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) <span class="built_in">change</span>(k*<span class="number">2</span>+<span class="number">1</span>,l,r,x);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">change</span>(k*<span class="number">2</span>,l,mid,x),<span class="built_in">change</span>(k*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r,x);</span><br><span class="line">    tree[k].sum=tree[k*<span class="number">2</span>].sum+tree[k*<span class="number">2</span>+<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[k].lazy) <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">if</span>(tree[k].l==l&amp;&amp;tree[k].r==r) <span class="keyword">return</span> tree[k].sum;</span><br><span class="line">    <span class="type">int</span> mid=(tree[k].l+tree[k].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> <span class="built_in">query</span>(k*<span class="number">2</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> <span class="built_in">query</span>(k*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(k*<span class="number">2</span>,l,mid)+<span class="built_in">query</span>(k*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;k;</span><br><span class="line">            <span class="built_in">change</span>(<span class="number">1</span>,l,r,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">query</span>(<span class="number">1</span>,l,r)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P3373">模板 $2$</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">arr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r,sum;</span><br><span class="line">    <span class="type">int</span> lazy1;<span class="comment">// 乘法</span></span><br><span class="line">    <span class="type">int</span> lazy2;<span class="comment">// 加法 </span></span><br><span class="line">&#125;tree[<span class="number">400002</span>];</span><br><span class="line"><span class="type">int</span> n,m,mo;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100002</span>];</span><br><span class="line"><span class="type">int</span> x,l,r,k;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[k*<span class="number">2</span>].sum=((tree[k*<span class="number">2</span>].r-tree[k*<span class="number">2</span>].l+<span class="number">1</span>)*tree[k].lazy2%mo+tree[k*<span class="number">2</span>].sum*tree[k].lazy1%mo)%mo;</span><br><span class="line">    tree[k*<span class="number">2</span>+<span class="number">1</span>].sum=((tree[k*<span class="number">2</span>+<span class="number">1</span>].r-tree[k*<span class="number">2</span>+<span class="number">1</span>].l+<span class="number">1</span>)*tree[k].lazy2%mo+tree[k*<span class="number">2</span>+<span class="number">1</span>].sum*tree[k].lazy1%mo)%mo;</span><br><span class="line">    tree[k*<span class="number">2</span>].lazy1=(tree[k*<span class="number">2</span>].lazy1*tree[k].lazy1)%mo;</span><br><span class="line">    tree[k*<span class="number">2</span>+<span class="number">1</span>].lazy1=(tree[k*<span class="number">2</span>+<span class="number">1</span>].lazy1*tree[k].lazy1)%mo;</span><br><span class="line">    tree[k*<span class="number">2</span>].lazy2=(tree[k*<span class="number">2</span>].lazy2*tree[k].lazy1%mo+tree[k].lazy2)%mo;</span><br><span class="line">    tree[k*<span class="number">2</span>+<span class="number">1</span>].lazy2=(tree[k*<span class="number">2</span>+<span class="number">1</span>].lazy2*tree[k].lazy1%mo+tree[k].lazy2)%mo;</span><br><span class="line">    tree[k].lazy1=<span class="number">1</span>;tree[k].lazy2=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[k].l=l;tree[k].r=r;tree[k].lazy1=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[k].sum=a[l]%mo;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(k*<span class="number">2</span>,l,mid);<span class="built_in">build</span>(k*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    tree[k].sum=(tree[k*<span class="number">2</span>].sum+tree[k*<span class="number">2</span>+<span class="number">1</span>].sum)%mo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change1</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[k].l==l&amp;&amp;tree[k].r==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[k].sum=(tree[k].sum*x)%mo;</span><br><span class="line">        tree[k].lazy1=(tree[k].lazy1*x)%mo;</span><br><span class="line">        tree[k].lazy2=(tree[k].lazy2*x)%mo;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid=(tree[k].l+tree[k].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) <span class="built_in">change1</span>(k*<span class="number">2</span>,l,r,x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) <span class="built_in">change1</span>(k*<span class="number">2</span>+<span class="number">1</span>,l,r,x);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">change1</span>(k*<span class="number">2</span>,l,mid,x),<span class="built_in">change1</span>(k*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r,x);</span><br><span class="line">    tree[k].sum=(tree[k*<span class="number">2</span>].sum+tree[k*<span class="number">2</span>+<span class="number">1</span>].sum)%mo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change2</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[k].l==l&amp;&amp;tree[k].r==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[k].sum=(tree[k].sum+x*(r-l+<span class="number">1</span>)%mo)%mo;</span><br><span class="line">        tree[k].lazy2=(tree[k].lazy2+x)%mo;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid=(tree[k].l+tree[k].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) <span class="built_in">change2</span>(k*<span class="number">2</span>,l,r,x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) <span class="built_in">change2</span>(k*<span class="number">2</span>+<span class="number">1</span>,l,r,x);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">change2</span>(k*<span class="number">2</span>,l,mid,x),<span class="built_in">change2</span>(k*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r,x);</span><br><span class="line">    tree[k].sum=(tree[k*<span class="number">2</span>].sum+tree[k*<span class="number">2</span>+<span class="number">1</span>].sum)%mo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[k].l==l&amp;&amp;tree[k].r==r) <span class="keyword">return</span> tree[k].sum;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid=(tree[k].l+tree[k].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> <span class="built_in">query</span>(k*<span class="number">2</span>,l,r)%mo;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> <span class="built_in">query</span>(k*<span class="number">2</span>+<span class="number">1</span>,l,r)%mo;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">query</span>(k*<span class="number">2</span>,l,mid)+<span class="built_in">query</span>(k*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r))%mo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;mo;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;k;</span><br><span class="line">            <span class="built_in">change1</span>(<span class="number">1</span>,l,r,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;k;</span><br><span class="line">            <span class="built_in">change2</span>(<span class="number">1</span>,l,r,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">query</span>(<span class="number">1</span>,l,r)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P2572">序列操作</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">arr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    <span class="type">int</span> lazy;<span class="comment">// 取反操作</span></span><br><span class="line">    <span class="type">int</span> sum;<span class="comment">// 区间中 1 的个数</span></span><br><span class="line">    <span class="type">int</span> to;<span class="comment">// 改为 0 或 1，-1 表示没改</span></span><br><span class="line">    <span class="type">int</span> conl0;<span class="comment">// 从 l 往 r 有多少续的 0</span></span><br><span class="line">    <span class="type">int</span> conr0;<span class="comment">// 从 r 往 l 有多少续的 0</span></span><br><span class="line">    <span class="type">int</span> conl1;<span class="comment">// 从 l 往 r 有多少续的 1</span></span><br><span class="line">    <span class="type">int</span> conr1;<span class="comment">// 从 r 往 l 有多少续的 1</span></span><br><span class="line">    <span class="type">int</span> ma0;<span class="comment">// 最长连续 0 的个数</span></span><br><span class="line">    <span class="type">int</span> ma1;<span class="comment">// 最长连续 1 的个数</span></span><br><span class="line">    <span class="type">int</span> len;<span class="comment">// 区间长度</span></span><br><span class="line">&#125;tree[<span class="number">400002</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100002</span>];</span><br><span class="line"><span class="type">int</span> op,x,y;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MIN</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">MAX</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MAX</span>(<span class="built_in">MAX</span>(a,b),c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[k].sum=tree[k*<span class="number">2</span>].sum+tree[k*<span class="number">2</span>+<span class="number">1</span>].sum;</span><br><span class="line">    <span class="keyword">if</span>(tree[k*<span class="number">2</span>].ma0==tree[k*<span class="number">2</span>].len) tree[k].conl0=tree[k*<span class="number">2</span>].len+tree[k*<span class="number">2</span>+<span class="number">1</span>].conl0;</span><br><span class="line">        <span class="keyword">else</span> tree[k].conl0=tree[k*<span class="number">2</span>].conl0;</span><br><span class="line">    <span class="keyword">if</span>(tree[k*<span class="number">2</span>+<span class="number">1</span>].ma0==tree[k*<span class="number">2</span>+<span class="number">1</span>].len) tree[k].conr0=tree[k*<span class="number">2</span>+<span class="number">1</span>].len+tree[k*<span class="number">2</span>].conr0;</span><br><span class="line">        <span class="keyword">else</span> tree[k].conr0=tree[k*<span class="number">2</span>+<span class="number">1</span>].conr0;</span><br><span class="line">    <span class="keyword">if</span>(tree[k*<span class="number">2</span>].ma1==tree[k*<span class="number">2</span>].len) tree[k].conl1=tree[k*<span class="number">2</span>].len+tree[k*<span class="number">2</span>+<span class="number">1</span>].conl1;</span><br><span class="line">        <span class="keyword">else</span> tree[k].conl1=tree[k*<span class="number">2</span>].conl1;</span><br><span class="line">    <span class="keyword">if</span>(tree[k*<span class="number">2</span>+<span class="number">1</span>].ma1==tree[k*<span class="number">2</span>+<span class="number">1</span>].len) tree[k].conr1=tree[k*<span class="number">2</span>+<span class="number">1</span>].len+tree[k*<span class="number">2</span>].conr1;</span><br><span class="line">        <span class="keyword">else</span> tree[k].conr1=tree[k*<span class="number">2</span>+<span class="number">1</span>].conr1;</span><br><span class="line">    tree[k].ma0=<span class="built_in">Max</span>(tree[k*<span class="number">2</span>].ma0,tree[k*<span class="number">2</span>+<span class="number">1</span>].ma0,tree[k*<span class="number">2</span>].conr0+tree[k*<span class="number">2</span>+<span class="number">1</span>].conl0);</span><br><span class="line">    tree[k].ma1=<span class="built_in">Max</span>(tree[k*<span class="number">2</span>].ma1,tree[k*<span class="number">2</span>+<span class="number">1</span>].ma1,tree[k*<span class="number">2</span>].conr1+tree[k*<span class="number">2</span>+<span class="number">1</span>].conl1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[k].to==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[k*<span class="number">2</span>].ma0=tree[k*<span class="number">2</span>].conl0=tree[k*<span class="number">2</span>].conr0=tree[k*<span class="number">2</span>].len;</span><br><span class="line">        tree[k*<span class="number">2</span>].sum=tree[k*<span class="number">2</span>].ma1=tree[k*<span class="number">2</span>].conl1=tree[k*<span class="number">2</span>].conr1=<span class="number">0</span>;</span><br><span class="line">        tree[k*<span class="number">2</span>+<span class="number">1</span>].ma0=tree[k*<span class="number">2</span>+<span class="number">1</span>].conl0=tree[k*<span class="number">2</span>+<span class="number">1</span>].conr0=tree[k*<span class="number">2</span>+<span class="number">1</span>].len;</span><br><span class="line">        tree[k*<span class="number">2</span>+<span class="number">1</span>].sum=tree[k*<span class="number">2</span>+<span class="number">1</span>].ma1=tree[k*<span class="number">2</span>+<span class="number">1</span>].conl1=tree[k*<span class="number">2</span>+<span class="number">1</span>].conr1=<span class="number">0</span>;</span><br><span class="line">        tree[k*<span class="number">2</span>].to=<span class="number">0</span>;tree[k*<span class="number">2</span>].lazy=<span class="number">0</span>;</span><br><span class="line">        tree[k*<span class="number">2</span>+<span class="number">1</span>].to=<span class="number">0</span>;tree[k*<span class="number">2</span>+<span class="number">1</span>].lazy=<span class="number">0</span>;</span><br><span class="line">        tree[k].to=<span class="number">-1</span>;tree[k].lazy=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tree[k].to==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[k*<span class="number">2</span>].ma0=tree[k*<span class="number">2</span>].conl0=tree[k*<span class="number">2</span>].conr0=<span class="number">0</span>;</span><br><span class="line">        tree[k*<span class="number">2</span>].sum=tree[k*<span class="number">2</span>].ma1=tree[k*<span class="number">2</span>].conl1=tree[k*<span class="number">2</span>].conr1=tree[k*<span class="number">2</span>].len;</span><br><span class="line">        tree[k*<span class="number">2</span>+<span class="number">1</span>].ma0=tree[k*<span class="number">2</span>+<span class="number">1</span>].conl0=tree[k*<span class="number">2</span>+<span class="number">1</span>].conr0=<span class="number">0</span>;</span><br><span class="line">        tree[k*<span class="number">2</span>+<span class="number">1</span>].sum=tree[k*<span class="number">2</span>+<span class="number">1</span>].ma1=tree[k*<span class="number">2</span>+<span class="number">1</span>].conl1=tree[k*<span class="number">2</span>+<span class="number">1</span>].conr1=tree[k*<span class="number">2</span>+<span class="number">1</span>].len;</span><br><span class="line">        tree[k*<span class="number">2</span>].to=<span class="number">1</span>;tree[k*<span class="number">2</span>].lazy=<span class="number">0</span>;</span><br><span class="line">        tree[k*<span class="number">2</span>+<span class="number">1</span>].to=<span class="number">1</span>;tree[k*<span class="number">2</span>+<span class="number">1</span>].lazy=<span class="number">0</span>;</span><br><span class="line">        tree[k].to=<span class="number">-1</span>;tree[k].lazy=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tree[k].lazy)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[k*<span class="number">2</span>].sum=tree[k*<span class="number">2</span>].len-tree[k*<span class="number">2</span>].sum;</span><br><span class="line">        tree[k*<span class="number">2</span>+<span class="number">1</span>].sum=tree[k*<span class="number">2</span>+<span class="number">1</span>].len-tree[k*<span class="number">2</span>+<span class="number">1</span>].sum;</span><br><span class="line">        <span class="built_in">swap</span>(tree[k*<span class="number">2</span>].ma0,tree[k*<span class="number">2</span>].ma1);</span><br><span class="line">        <span class="built_in">swap</span>(tree[k*<span class="number">2</span>+<span class="number">1</span>].ma0,tree[k*<span class="number">2</span>+<span class="number">1</span>].ma1);</span><br><span class="line">        <span class="built_in">swap</span>(tree[k*<span class="number">2</span>].conl0,tree[k*<span class="number">2</span>].conl1);</span><br><span class="line">        <span class="built_in">swap</span>(tree[k*<span class="number">2</span>+<span class="number">1</span>].conl0,tree[k*<span class="number">2</span>+<span class="number">1</span>].conl1);</span><br><span class="line">        <span class="built_in">swap</span>(tree[k*<span class="number">2</span>].conr0,tree[k*<span class="number">2</span>].conr1);</span><br><span class="line">        <span class="built_in">swap</span>(tree[k*<span class="number">2</span>+<span class="number">1</span>].conr0,tree[k*<span class="number">2</span>+<span class="number">1</span>].conr1);</span><br><span class="line">        <span class="keyword">if</span>(tree[k*<span class="number">2</span>].to==<span class="number">0</span>) tree[k*<span class="number">2</span>].to=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tree[k*<span class="number">2</span>].to==<span class="number">1</span>) tree[k*<span class="number">2</span>].to=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> tree[k*<span class="number">2</span>].lazy=<span class="number">1</span>-tree[k*<span class="number">2</span>].lazy;</span><br><span class="line">        <span class="keyword">if</span>(tree[k*<span class="number">2</span>+<span class="number">1</span>].to==<span class="number">0</span>) tree[k*<span class="number">2</span>+<span class="number">1</span>].to=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tree[k*<span class="number">2</span>+<span class="number">1</span>].to==<span class="number">1</span>) tree[k*<span class="number">2</span>+<span class="number">1</span>].to=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> tree[k*<span class="number">2</span>+<span class="number">1</span>].lazy=<span class="number">1</span>-tree[k*<span class="number">2</span>+<span class="number">1</span>].lazy;</span><br><span class="line">        tree[k].lazy=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[k].l=l;tree[k].r=r;</span><br><span class="line">    tree[k].lazy=<span class="number">0</span>;</span><br><span class="line">    tree[k].to=<span class="number">-1</span>;</span><br><span class="line">    tree[k].len=r-l+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[k].sum=a[l];</span><br><span class="line">        <span class="keyword">if</span>(a[l]==<span class="number">0</span>) tree[k].conl0=tree[k].conr0=tree[k].ma0=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[l]==<span class="number">1</span>) tree[k].conl1=tree[k].conr1=tree[k].ma1=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(k*<span class="number">2</span>,l,mid);<span class="built_in">build</span>(k*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">update</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change_to0</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">if</span>(tree[k].l==l&amp;&amp;tree[k].r==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[k].ma0=tree[k].conl0=tree[k].conr0=tree[k].len;</span><br><span class="line">        tree[k].ma1=tree[k].conl1=tree[k].conr1=<span class="number">0</span>;</span><br><span class="line">        tree[k].sum=<span class="number">0</span>;</span><br><span class="line">        tree[k].to=<span class="number">0</span>;</span><br><span class="line">        tree[k].lazy=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(tree[k].l+tree[k].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) <span class="built_in">change_to0</span>(k*<span class="number">2</span>,l,r);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) <span class="built_in">change_to0</span>(k*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">change_to0</span>(k*<span class="number">2</span>,l,mid),<span class="built_in">change_to0</span>(k*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">update</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change_to1</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">if</span>(tree[k].l==l&amp;&amp;tree[k].r==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[k].ma0=tree[k].conl0=tree[k].conr0=<span class="number">0</span>;</span><br><span class="line">        tree[k].ma1=tree[k].conl1=tree[k].conr1=tree[k].len;</span><br><span class="line">        tree[k].sum=tree[k].len;</span><br><span class="line">        tree[k].to=<span class="number">1</span>;</span><br><span class="line">        tree[k].lazy=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(tree[k].l+tree[k].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) <span class="built_in">change_to1</span>(k*<span class="number">2</span>,l,r);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) <span class="built_in">change_to1</span>(k*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">change_to1</span>(k*<span class="number">2</span>,l,mid),<span class="built_in">change_to1</span>(k*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">update</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change_lazy</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">if</span>(tree[k].l==l&amp;&amp;tree[k].r==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[k].sum=tree[k].len-tree[k].sum;</span><br><span class="line">        <span class="built_in">swap</span>(tree[k].ma0,tree[k].ma1);</span><br><span class="line">        <span class="built_in">swap</span>(tree[k].conl0,tree[k].conl1);</span><br><span class="line">        <span class="built_in">swap</span>(tree[k].conr0,tree[k].conr1);</span><br><span class="line">        tree[k].lazy=<span class="number">1</span>-tree[k].lazy;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(tree[k].l+tree[k].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) <span class="built_in">change_lazy</span>(k*<span class="number">2</span>,l,r);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) <span class="built_in">change_lazy</span>(k*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">change_lazy</span>(k*<span class="number">2</span>,l,mid),<span class="built_in">change_lazy</span>(k*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">update</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_sum</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">if</span>(tree[k].l==l&amp;&amp;tree[k].r==r) <span class="keyword">return</span> tree[k].sum;</span><br><span class="line">    <span class="type">int</span> mid=(tree[k].l+tree[k].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> <span class="built_in">query_sum</span>(k*<span class="number">2</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> <span class="built_in">query_sum</span>(k*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query_sum</span>(k*<span class="number">2</span>,l,mid)+<span class="built_in">query_sum</span>(k*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_con</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="keyword">if</span>(tree[k].l==l&amp;&amp;tree[k].r==r) <span class="keyword">return</span> tree[k].ma1;</span><br><span class="line">    <span class="type">int</span> mid=(tree[k].l+tree[k].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> <span class="built_in">query_con</span>(k*<span class="number">2</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> <span class="built_in">query_con</span>(k*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Max</span>(<span class="built_in">query_con</span>(k*<span class="number">2</span>,l,mid),<span class="built_in">query_con</span>(k*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r),<span class="built_in">MIN</span>(tree[k*<span class="number">2</span>+<span class="number">1</span>].conl1,r-mid)+<span class="built_in">MIN</span>(tree[k*<span class="number">2</span>].conr1,mid-l+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>*n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].l==<span class="number">0</span>&amp;&amp;tree[i].r==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        cout&lt;&lt;tree[i].l&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;tree[i].r&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;tree[i].conl1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;tree[i].conr1&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>*n;++i) tree[i].to=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        x++;y++;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">0</span>) <span class="built_in">change_to0</span>(<span class="number">1</span>,x,y);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>) <span class="built_in">change_to1</span>(<span class="number">1</span>,x,y);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">2</span>) <span class="built_in">change_lazy</span>(<span class="number">1</span>,x,y);</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">3</span>) cout&lt;&lt;<span class="built_in">query_sum</span>(<span class="number">1</span>,x,y)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">4</span>) cout&lt;&lt;<span class="built_in">query_con</span>(<span class="number">1</span>,x,y)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment">//        if(op==5) check();</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P4145">区间开平方</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">arr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r,sum,ma;</span><br><span class="line">&#125;tree[<span class="number">1600002</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100002</span>];</span><br><span class="line"><span class="type">int</span> k,l,r;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[k].sum=tree[k*<span class="number">2</span>].sum+tree[k*<span class="number">2</span>+<span class="number">1</span>].sum;</span><br><span class="line">    tree[k].ma=<span class="built_in">Max</span>(tree[k*<span class="number">2</span>].ma,tree[k*<span class="number">2</span>+<span class="number">1</span>].ma);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[k].l=l;tree[k].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[k].sum=tree[k].ma=a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(k*<span class="number">2</span>,l,mid);<span class="built_in">build</span>(k*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">update</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[k].l==tree[k].r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[k].sum=<span class="built_in">sqrt</span>(tree[k].sum);</span><br><span class="line">        tree[k].ma=<span class="built_in">sqrt</span>(tree[k].ma);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(tree[k].l+tree[k].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid&amp;&amp;tree[k*<span class="number">2</span>].ma&gt;<span class="number">1</span>) <span class="built_in">change</span>(k*<span class="number">2</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid&amp;&amp;tree[k*<span class="number">2</span>+<span class="number">1</span>].ma&gt;<span class="number">1</span>) <span class="built_in">change</span>(k*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="built_in">update</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==tree[k].l&amp;&amp;r==tree[k].r) <span class="keyword">return</span> tree[k].sum;</span><br><span class="line">    <span class="type">int</span> mid=(tree[k].l+tree[k].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> <span class="built_in">query</span>(k*<span class="number">2</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> <span class="built_in">query</span>(k*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(k*<span class="number">2</span>,l,mid)+<span class="built_in">query</span>(k*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;k&gt;&gt;l&gt;&gt;r;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r) <span class="built_in">swap</span>(l,r);</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="built_in">change</span>(<span class="number">1</span>,l,r);</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;<span class="built_in">query</span>(<span class="number">1</span>,l,r)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P1253">区间最大值</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">arr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r,add,ma,cover;</span><br><span class="line">&#125;tree[<span class="number">8000002</span>];</span><br><span class="line"><span class="type">int</span> n,q;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1000002</span>];</span><br><span class="line"><span class="type">int</span> op,l,r,x;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>,w=<span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)w=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) s=s*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>,ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cover_down</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[k].cover==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    tree[k*<span class="number">2</span>].add=tree[k*<span class="number">2</span>+<span class="number">1</span>].add=<span class="number">0</span>;</span><br><span class="line">    tree[k*<span class="number">2</span>].ma=tree[k*<span class="number">2</span>+<span class="number">1</span>].ma=tree[k].cover;</span><br><span class="line">    tree[k*<span class="number">2</span>].cover=tree[k*<span class="number">2</span>+<span class="number">1</span>].cover=tree[k].cover;</span><br><span class="line">    tree[k].cover=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_down</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tree[k].add) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">cover_down</span>(k);</span><br><span class="line">    tree[k*<span class="number">2</span>].ma+=tree[k].add;</span><br><span class="line">    tree[k*<span class="number">2</span>+<span class="number">1</span>].ma+=tree[k].add;</span><br><span class="line">    tree[k*<span class="number">2</span>].add+=tree[k].add;</span><br><span class="line">    tree[k*<span class="number">2</span>+<span class="number">1</span>].add+=tree[k].add;</span><br><span class="line">    tree[k].add=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cover_down</span>(k);</span><br><span class="line">    <span class="built_in">add_down</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[k].l=l;tree[k].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[k].ma=a[l];</span><br><span class="line">        tree[k].add=<span class="number">0</span>;</span><br><span class="line">        tree[k].cover=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">build</span>(k*<span class="number">2</span>,l,mid);<span class="built_in">build</span>(k*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    tree[k].ma=<span class="built_in">Max</span>(tree[k*<span class="number">2</span>].ma,tree[k*<span class="number">2</span>+<span class="number">1</span>].ma);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change_cover</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[k].l==l&amp;&amp;tree[k].r==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[k].add=<span class="number">0</span>;</span><br><span class="line">        tree[k].ma=x;</span><br><span class="line">        tree[k].cover=x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid=(tree[k].l+tree[k].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) <span class="built_in">change_cover</span>(k*<span class="number">2</span>,l,r,x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) <span class="built_in">change_cover</span>(k*<span class="number">2</span>+<span class="number">1</span>,l,r,x);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">change_cover</span>(k*<span class="number">2</span>,l,mid,x),<span class="built_in">change_cover</span>(k*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r,x);</span><br><span class="line">    tree[k].ma=<span class="built_in">Max</span>(tree[k*<span class="number">2</span>].ma,tree[k*<span class="number">2</span>+<span class="number">1</span>].ma);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change_add</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[k].l==l&amp;&amp;tree[k].r==r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cover_down</span>(k);</span><br><span class="line">        tree[k].add+=x;</span><br><span class="line">        tree[k].ma+=x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid=(tree[k].l+tree[k].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) <span class="built_in">change_add</span>(k*<span class="number">2</span>,l,r,x);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) <span class="built_in">change_add</span>(k*<span class="number">2</span>+<span class="number">1</span>,l,r,x);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">change_add</span>(k*<span class="number">2</span>,l,mid,x),<span class="built_in">change_add</span>(k*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r,x);</span><br><span class="line">    tree[k].ma=<span class="built_in">Max</span>(tree[k*<span class="number">2</span>].ma,tree[k*<span class="number">2</span>+<span class="number">1</span>].ma);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[k].l==l&amp;&amp;tree[k].r==r) <span class="keyword">return</span> tree[k].ma;</span><br><span class="line">    <span class="built_in">pushdown</span>(k);</span><br><span class="line">    <span class="type">int</span> mid=(tree[k].l+tree[k].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> <span class="built_in">query</span>(k*<span class="number">2</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> <span class="built_in">query</span>(k*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Max</span>(<span class="built_in">query</span>(k*<span class="number">2</span>,l,mid),<span class="built_in">query</span>(k*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();q=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) a[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n*<span class="number">4</span>;++i) tree[i].cover=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        op=<span class="built_in">read</span>();l=<span class="built_in">read</span>();r=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>) <span class="built_in">change_cover</span>(<span class="number">1</span>,l,r,<span class="built_in">read</span>());</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">2</span>) <span class="built_in">change_add</span>(<span class="number">1</span>,l,r,<span class="built_in">read</span>());</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">3</span>) cout&lt;&lt;<span class="built_in">query</span>(<span class="number">1</span>,l,r)&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h2><p>学的太晚了（悲）。</p><p>参考资料：</p><p><a href="https://blog.csdn.net/huangzihaoal/article/details/81813454">https://blog.csdn.net/huangzihaoal/article/details/81813454</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
